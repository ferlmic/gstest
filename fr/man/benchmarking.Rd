% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/benchmarking.R
\name{benchmarking}
\alias{benchmarking}
\title{Rétablir les contraintes temporelles}
\usage{
benchmarking(
  series_df,
  benchmarks_df,
  rho,
  lambda,
  biasOption,
  bias = NA,
  tolV = 0.001,
  tolP = NA,
  warnNegResult = TRUE,
  tolN = -0.001,
  var = "value",
  with = NULL,
  by = NULL,
  verbose = FALSE,

  # Nouveau dans G-Séries 3.0
  constant = 0,
  negInput_option = 0,
  allCols = FALSE,
  quiet = FALSE
)
}
\arguments{
\item{series_df}{(obligatoire)

\emph{Data frame}, ou objet compatible, qui contient les données de la (des) série(s) indicatrice(s) à étalonner. En plus de
la (des) variable(s) contenant les données, spécifiée(s) avec l'argument \code{var}, le \emph{data frame} doit aussi contenir deux
variables numériques, \code{year} et \code{period}, identifiant les périodes des séries indicatrices.}

\item{benchmarks_df}{(obligatoire)

\emph{Data frame}, ou objet compatible, qui contient les étalons. En plus de la (des) variable(s) contenant les données,
spécifiée(s) avec l'argument \code{with}, le \emph{data frame} doit aussi contenir quatre variables numériques, \code{startYear},
\code{startPeriod}, \code{endYear} et \code{endPeriod}, identifiant les périodes des séries indicatrices couvertes par chaque étalon.}

\item{rho}{(obligatoire)

Nombre réel compris dans l'intervalle \eqn{[0,1]} qui spécifie la valeur du paramètre autorégressif \eqn{\rho}.
Voir la section \strong{Détails} pour plus d'informations sur l'effet du paramètre \eqn{\rho}.}

\item{lambda}{(obligatoire)

Nombre réel, avec des valeurs suggérées dans l'intervalle \eqn{[-3,3]}, qui spécifie la valeur du paramètre du modèle
d'ajustement \eqn{\lambda}. Les valeurs typiques sont \code{lambda = 0.0} pour un modèle additif et \code{lambda = 1.0} pour un
modèle proportionnel.}

\item{biasOption}{(obligatoire)

Spécification de l'option d'estimation du biais :
\itemize{
\item \code{1} : Ne pas estimer le biais. Le biais utilisé pour corriger la série indicatrice sera la valeur
spécifiée avec l'argument \code{bias}.
\item \code{2} : Estimer le biais, afficher le résultat, mais ne pas l'utiliser. Le biais utilisé pour corriger
la série indicatrice sera la valeur spécifiée avec l'argument \code{bias}.
\item \code{3} : Estimer le biais, afficher le résultat et utiliser le biais estimé pour corriger la série indicatrice.
Toute valeur spécifiée avec l'argument \code{bias} sera ignorée.
}

L'argument \code{biasOption} n'est pas utilisé quand \code{rho = 1.0}. Voir la section \strong{Détails} pour plus d'informations sur
le biais.}

\item{bias}{(optionnel)

Nombre réel, ou \code{NA}, spécifiant la valeur du biais défini par l'utilisateur à utiliser pour la correction de la série
indicatrice avant de procéder à l'étalonnage. Le biais est ajouté à la série indicatrice avec un modèle additif
(argument \code{lambda = 0.0}) alors qu'il est multiplié dans le cas contraire (argument \code{lambda != 0.0}). Aucune correction
de biais n'est appliquée lorsque \code{bias = NA}, ce qui équivaut à spécifier \code{bias = 0.0} lorsque \code{lambda = 0.0} et
\code{bias = 1.0} dans le cas contraire. L'argument \code{bias} n'est pas utilisé lorsque \code{biasOption = 3} ou \code{rho = 1.0}. Voir la
section \strong{Détails} pour plus d'informations sur le biais.

\strong{La valeur par défaut} est \code{bias = NA} (pas de biais défini par l'utilisateur).}

\item{tolV, tolP}{(optionnel)

Nombre réel non négatif, ou \code{NA}, spécifiant la tolérance, en valeur absolue ou en pourcentage, à utiliser pour
la validation des étalons contraignants (coefficient d'altérabilité de \eqn{0.0}) en sortie. Cette validation consiste à
comparer la valeur des étalons contraignants en entrée à la valeur équivalente calculée à partir des données de la série
étalonnée (sortie). Les arguments \code{tolV} et \code{tolP} ne peuvent pas être spécifiés tous les deux à la fois (l'un doit être
spécifié tandis que l'autre doit être \code{NA}).

\strong{Exemple :} pour une tolérance de 10 \emph{unités}, spécifiez \verb{tolV = 10, tolP = NA}; pour une tolérance de 1\%,
spécifiez \verb{tolV = NA, tolP = 0.01}.

\strong{Les valeurs par défaut} sont \code{tolV = 0.001} et \code{tolP = NA}.}

\item{warnNegResult}{(optionnel)

Argument logique (\emph{logical}) spécifiant si un message d'avertissement doit être affiché lorsqu'une valeur négative
créée par la fonction dans la série étalonnée (en sortie) est inférieure au seuil spécifié avec l'argument \code{tolN}.

\strong{La valeur par défaut} est \code{warnNegResult = TRUE}.}

\item{tolN}{(optionnel)

Nombre réel négatif spécifiant le seuil pour l'identification des valeurs négatives. Une valeur est considérée
négative lorsqu'elle est inférieure à ce seuil.

\strong{La valeur par défaut} est \code{tolN = -0.001}.}

\item{var}{(optionnel)

Vecteur (longueur minimale de 1) de chaînes de caractères spécifiant le(s) nom(s) de variable(s) du \emph{data frame} des séries
indicatrices (argument \code{series_df}) contenant les valeurs et (optionnellement) les coefficients d'altérabilité définis par
l'utilisateur de la (des) série(s) à étalonner. Ces variables doivent être numériques.

La syntaxe est \code{var = c("serie1 </ alt_ser1>", "serie2 </ alt_ser2>", ...)}. Des coefficients d'altérabilité par défaut
de \eqn{1.0} sont utilisés lorsqu'une variable de coefficients d'altérabilité définie par l'utilisateur n'est pas spécifiée
à côté d'une variable de série indicatrice. Voir la section \strong{Détails} pour plus d'informations sur les coefficients
d'altérabilité.

\strong{Exemple :} \code{var = "value / alter"} étalonnerait la variable \code{value} du \emph{data frame} des séries indicatrices avec les
coefficients d'altérabilité contenus dans la variable \code{alter} tandis que \code{var = c("value / alter", "value2")} étalonnerait
en plus la variable \code{value2} avec des coefficients d'altérabilité par défaut de \eqn{1.0}.

\strong{La valeur par défaut} est \code{var = "value"} (étalonner la variable \code{value} avec des coefficients d'altérabilité par défaut
de \eqn{1.0}).}

\item{with}{(optionnel)

Vecteur (même longueur que l'argument \code{var}) de chaînes de caractères, ou \code{NULL}, spécifiant le(s) nom(s) de variable(s)
du \emph{data frame} des étalons (argument \code{benchmarks_df}) contenant les valeurs et (optionnellement) les coefficients
d'altérabilité définis par l'utilisateur des étalons. Ces variables doivent être numériques. La spécification de \code{with = NULL}
entraîne l'utilisation de variable(s) d'étalons correspondant à la (aux) variable(s) spécifiée(s) avec l'argument \code{var} sans
coefficients d'altérabilité d'étalons définis par l'utilisateur (c'est  à dire des coefficients d'altérabilité par défaut de
\eqn{0.0} correspondant à des étalons contraignants).

La syntaxe est \code{with = NULL} ou \code{with = c("bmk1 </ alt_bmk1>", "bmk2 </ alt_bmk2>", ...)}. Des coefficients d'altérabilité
par défaut de \eqn{0.0} (étalons contraignants) sont utilisés lorsqu'une variable de coefficients d'altérabilité définie
par l'utilisateur n'est pas spécifiée à côté d'une variable d'étalon. Voir la section \strong{Détails} pour plus d'informations
sur les coefficients d'altérabilité.

\strong{Exemple :} \code{with = "val_bmk"} utiliserait la variable \code{val_bmk} du \emph{data frame} des étalons avec les coefficients
d'altérabilité par défaut de \eqn{0.0} pour étalonner la série indicatrice tandis que
\code{with = c("val_bmk", "val_bmk2 / alt_bmk2")} étalonnerait en plus une deuxième série indicatrice en utilisant la variable
d'étalons \code{val_bmk2} avec les coefficients d'altérabilité d'étalons contenus dans la variable \code{alt_bmk2}.

\strong{La valeur par défaut} est \code{with = NULL} (même(s) variable(s) d'étalons que l'argument \code{var} avec des coefficients
d'altérabilité d'étalons par défaut de \eqn{0.0}).}

\item{by}{(optionnel)

Vecteur (longueur minimale de 1) de chaînes de caractères, ou \code{NULL}, spécifiant le(s) nom(s) de variable(s) dans les
\emph{data frames} d'entrée (arguments \code{series_df} et \code{benchmarks_df}) à utiliser pour former des groupes (pour le traitement
« groupes-BY ») et permettre l'étalonnage de plusieurs séries en un seul appel de fonction. Les variables groupes-BY
peuvent être numériques ou caractères (facteurs ou non), doivent être présentes dans les deux \emph{data frames} d'entrée
et apparaîtront dans les trois \emph{data frames} de sortie (voir la section \strong{Valeur de retour}). Le traitement groupes-BY
n'est pas implémenté lorsque \code{by = NULL}. Voir « Étalonnage de plusieurs séries » dans la section \strong{Détails} pour plus
d'informations.

\strong{La valeur par défaut} est \code{by = NULL} (pas de traitement groupes-BY).}

\item{verbose}{(optionnel)

Argument logique (\emph{logical}) spécifiant si les informations sur les étapes intermédiaires avec le temps d'exécution
(temps réel et non le temps CPU) doivent être affichées. Notez que spécifier l'argument \code{quiet = TRUE} annulerait
l'argument \code{verbose}.

\strong{La valeur par défaut} est \code{verbose = FALSE}.}

\item{constant}{(optionnel)

Nombre réel qui spécifie une valeur à ajouter temporairement à la fois à la (aux) série(s) indicatrice(s) et aux étalons
avant de résoudre les problèmes d'étalonnage proportionnels (\code{lambda != 0.0}). La constante temporaire est enlevée de la
série étalonnée finale en sortie. Par exemple, la spécification d'une (petite) constante permettrait l'étalonnage
proportionnel avec \code{rho = 1} (étalonnage de  Denton proportionnel) sur avec des séries indicatrices qui comprennent des
valeurs de 0. Sinon, l'étalonnage proportionnel avec des valeurs de 0 pour la série indicatrice n'est possible que
lorsque \code{rho < 1}. Spécifier une constante avec l'étalonnage additif (\code{lambda = 0.0}) n'a pas d'impact sur les données
étalonnées résultantes. Les variables de données dans le \emph{data frame} de sortie \strong{graphTable} incluent la constante,
correspondant au problème d'étalonnage effectivement résolu par la fonction.

\strong{La valeur par défaut} est \code{constant = 0} (pas de constante additive temporaire).}

\item{negInput_option}{(optionnel)

Traitement des valeurs négatives dans les données d'entrée pour l'étalonnage proportionnel (\code{lambda != 0.0}) :
\itemize{
\item \code{0} : Ne pas autoriser les valeurs négatives pour l'étalonnage proportionnel. Un message d'erreur est affiché en
présence de valeurs négatives dans les séries indicatrices ou les étalons d'entrée et des valeurs manquantes (\code{NA})
sont renvoyées pour les séries étalonnées. Ceci correspond au comportement de G-Séries 2.0.
\item \code{1} : Autoriser les valeurs négatives pour l'étalonnage proportionnel mais avec l'affichage d'un message d'avertissement.
\item \code{2} : Autoriser les valeurs négatives pour l'étalonnage proportionnel sans afficher de message.
}

\strong{La valeur par défaut} est \code{negInput_option = 0} (ne pas autoriser les valeurs négatives pour l'étalonnage proportionnel).}

\item{allCols}{(optionnel)

Argument logique (\emph{logical}) spécifiant si toutes les variables du \emph{data frame} des séries indicatrices (argument \code{series_df}),
autres que \code{year} et \code{period}, déterminent l'ensemble des séries à étalonner. Les valeurs spécifiées avec les arguments \code{var}
et \code{with} sont ignorées lorsque \code{allCols = TRUE}, ce qui implique automatiquement des coefficients d'altérabilité par défaut,
et des variables avec les mêmes noms que les séries indicatrices doivent exister dans le \emph{data frame} des étalons (argument
\code{benchmarks_df}).

\strong{La valeur par défaut} est \code{allCols = FALSE}.}

\item{quiet}{(optionnel)

Argument logique (\emph{logical}) spécifiant s'il faut ou non afficher uniquement les informations essentielles telles que les
messages d'avertissements, les messages d'erreurs et les informations sur les variables (séries) ou les groupes-BY lorsque
plusieurs séries sont étalonnées en un seul appel à la fonction. Nous vous déconseillons d'\emph{envelopper} votre appel à
\code{\link[=benchmarking]{benchmarking()}} avec \code{\link[=suppressMessages]{suppressMessages()}} afin de supprimer l'affichage des informations sur les variables (séries) ou les
groupes-BY lors du traitement de plusieurs séries, car cela compliquerait le dépannage en cas de problèmes avec des séries
individuelles. Notez que la spécification de \code{quiet = TRUE} annulera également l'argument \code{verbose}.

\strong{La valeur par défaut} est \code{quiet = FALSE}.}
}
\value{
La fonction renvoie une liste de trois \emph{data frames} :
\itemize{
\item \strong{series} : \emph{data frame} contenant les données étalonnées (sortie principale de la fonction). Les variables BY spécifiées
avec l'argument \code{by} sont incluses dans le \emph{data frame} mais pas les variables de coefficient d'altérabilité spécifiées
avec l'argument \code{var}.
\item \strong{benchmarks} : copie du \emph{data frame} d'entrée des étalons (à l'exclusion des étalons non valides, le cas échéant).
Les variables BY spécifiées avec l'argument \code{by} sont incluses dans le \emph{data frame} mais pas les variables de coefficient
d'altérabilité spécifiées avec l'argument \code{with}.
\item \strong{graphTable} : \emph{data frame} contenant des données supplémentaires utiles pour produire des tableaux et des graphiques
analytiques (voir la fonction \code{\link[=plot_graphTable]{plot_graphTable()}}). Il contient les variables suivantes en plus des variables BY spécifiées
avec l'argument \code{by} :
\itemize{
\item \code{varSeries} : Nom de la variable de la série indicatrice
\item \code{varBenchmarks} : Nom de la variable des étalons
\item \code{altSeries} : Nom de la variable des coefficients d'altérabilité définis par l'utilisateur pour la série indicatrice
\item \code{altSeriesValue} : Coefficients d'altérabilité de la série indicatrice
\item \code{altbenchmarks} : Nom de la variable des coefficients d'altérabilité définis par l'utilisateur pour les étalons
\item \code{altBenchmarksValue} : Coefficients d'altérabilité des étalons
\item \code{t} : Identificateur de la période de la série indicatrice (1 à \eqn{T})
\item \code{m} : Identificateur des périodes de couverture de l'étalon (1 à \eqn{M})
\item \code{year} : Année civile du point de données
\item \code{period} : Valeur de la période (du cycle) du point de données (1 à \code{periodicity})
\item \code{constant} : Constante additive temporaire (argument \code{constant})
\item \code{rho} : Paramètre autorégressif \eqn{\rho} (argument \code{rho})
\item \code{lambda} : Paramètre du modèle d'ajustement \eqn{\lambda} (argument \code{lambda})
\item \code{bias} : Ajustement du biais (par défaut, défini par l'utilisateur ou biais estimé selon les arguments \code{biasOption}
et \code{bias})
\item \code{periodicity} : Le nombre maximum de périodes dans une année (par exemple 4 pour une série indicatrice trimestrielle)
\item \code{date} : Chaîne de caractères combinant les valeurs des variables \code{year} et \code{period}
\item \code{subAnnual} : Valeurs de la série indicatrice
\item \code{benchmarked} : Valeurs de la série étalonnée
\item \code{avgBenchmark} : Valeurs des étalons divisées par le nombre de périodes de couverture
\item \code{avgSubAnnual} : Valeurs moyennes de la série indicatrice (variable \code{subAnnual}) pour les périodes couvertes par les
étalons
\item \code{subAnnualCorrected} : Valeurs de la série indicatrice corrigée pour le biais
\item \code{benchmarkedSubAnnualRatio} : Différence (\eqn{\lambda = 0}) ou ratio (\eqn{\lambda \ne 0}{lambda != 0}) des valeurs
des variables \code{benchmarked} et \code{subAnnual}
\item \code{avgBenchmarkSubAnnualRatio} : Différence (\eqn{\lambda = 0}) ou ratio (\eqn{\lambda \ne 0}{lambda != 0}) des valeurs
des variables \code{avgBenchmark} et \code{avgSubAnnual}
\item \code{growthRateSubAnnual} : Différence (\eqn{\lambda = 0}) ou différence relative (\eqn{\lambda \ne 0}{lambda != 0}) d'une
période à l'autre des valeurs de la série indicatrice (variable \code{subAnnual})
\item \code{growthRateBenchmarked} : Différence (\eqn{\lambda = 0}) ou différence relative (\eqn{\lambda \ne 0}{lambda != 0}) d'une
période à l'autre des valeurs de la série étalonnée (variable \code{benchmarked})
}
}

Notes :
\itemize{
\item Le \emph{data frame} de sortie \strong{benchmarks} contient toujours les étalons originaux fournis dans le \emph{data frame} d'entrée
des étalons. Les étalons modifiés non contraignants, le cas échéant, peuvent être récupérés (calculés) à partir du \emph{data frame}
de sortie \strong{series}.
\item La fonction renvoie un objet \code{NULL} si une erreur se produit avant que le traitement des données ne puisse commencer.
Dans le cas contraire, si l'exécution est suffisamment avancée pour que le traitement des données puisse commencer, alors
un objet incomplet sera renvoyé en cas d'erreur (par exemple, un \emph{data frame} de sortie \strong{series} avec des valeurs \code{NA}
pour les données étalonnées).
\item La fonction renvoie des objets « data.frame » qui peuvent être explicitement convertis en d'autres types d'objets avec la
fonction \verb{as*()} appropriée (ex., \code{tibble::as_tibble()} convertirait n'importe lequel d'entre eux en tibble).
}
}
\description{
\emph{Réplication de la procédure BENCHMARKING de G-Séries 2.0 en SAS\eqn{^\circledR}{®} (PROC BENCHMARKING).
Voir la documentation de G-Séries 2.0 pour plus de détails (Statistique Canada 2016).}

Cette fonction assure la cohérence entre les données de séries chronologiques d'une même variable cible mesurée à des
fréquences différentes (ex., infra-annuellement et annuellement). L'étalonnage consiste à imposer le niveau de la série
d'étalons (ex., données annuelles) tout en minimisant, autant que possible, les révisions au mouvement observé dans
la série indicatrice (ex., données infra-annuelles). La fonction permet également l'étalonnage non contraignant où
la série d'étalons peut également être révisée.

La fonction peut également être utilisée pour des sujets liés à l'étalonnage tels que la \emph{distribution temporelle}
(action réciproque de l'étalonnage : désagrégation de la série d'étalons en observations plus fréquentes), la
\emph{calendarisation} (cas spécial de distribution temporelle) et le \emph{raccordement} (« \emph{linking} » : connexion de différents
segments de séries chronologiques en une série chronologique unique et cohérente).

Plusieurs séries peuvent être étalonnées en un seul appel de fonction.
}
\details{
Lorsque \eqn{\rho < 1}, cette fonction renvoie la solution des moindres carrés généralisés d'un cas particulier du modèle
général d'étalonnage basé sur la régression proposé par Dagum et Cholette (2006). Le modèle, sous forme matricielle, est le
suivant :
\deqn{\displaystyle
\begin{bmatrix} s^\dagger \\ a \end{bmatrix} = 
\begin{bmatrix} I \\ J \end{bmatrix} \theta + 
\begin{bmatrix} e \\ \varepsilon \end{bmatrix}
}{[s^dag; a] = [I; J] theta + [e; epsilion]}
où
\itemize{
\item \eqn{a} est le vecteur de longueur \eqn{M} des étalons.
\item \eqn{s^\dagger = \left\{
    \begin{array}{cl}
      s + b & \text{si } \lambda = 0 \\
      s \cdot b  & \text{sinon}
    \end{array} \right.
  }{s^dag = s + b si lambda = 0, s^dag = s * b sinon} est le vecteur de longueur \eqn{T} des valeurs de la série
indicatrice corrigée pour le biais, \eqn{s} désignant la série indicatrice initiale (d'entrée).
\item \eqn{b} est le bias, qui est spécifié avec l'argument \code{bias} lorsque \code{bias_option != 3} ou, lorsque
\code{bias_option = 3}, est estimé par \eqn{\hat{b} = \left\{
    \begin{array}{cl}
      \frac{{1_M}^\mathrm{T} (a - Js)}{{1_M}^\mathrm{T} J 1_T} & \text{si } \lambda = 0 \\
      \frac{{1_M}^\mathrm{T} a}{{1_M}^\mathrm{T} Js} & \text{sinon}
    \end{array} \right.
  }{b^hat = ({1_M}'(a - J s)) / ({1_M}' J 1_T) si \lambda = 0, b^hat = ({1_M}' a) / ({1_M}' J s) sinon}, où
\eqn{1_X = (1, ..., 1)^\mathrm{T}}{1_X = (1, ..., 1)'} est un vecteur de \eqn{1} de longueur \eqn{X}.
\item \eqn{J} est la matrice \eqn{M \times T}{M x T} des contraintes d'agrégation temporelles avec les éléments \if{latex}{\cr}
\eqn{j_{m, t} = \left\{
    \begin{array}{cl}
      1 & \text{si l'étalon } m \text{ couvre la période } t \\
      0 & \text{sinon}
    \end{array} \right.
  }{j_{m,t} = 1 si l'étalon m couvre la période t, j_{m,t} = 0 sinon}.
  
\item \eqn{\theta} est le vecteur des valeurs de la série finale (étalonnée).
\item \eqn{e \sim \left( 0, V_e \right)}{e ~ (0, V_e)} est le vecteur des erreurs de mesure de \eqn{s^\dagger}{s^dag} avec
matrice de covariance \eqn{V_e = C \Omega_e C}.
\item \eqn{C = \mathrm{diag} \left( \sqrt{c_{s^\dagger}} \left| s^\dagger \right|^\lambda \right)}{C = diag(\sqrt{c_{s^dag}} 
|s^dag|^lambda)} où \eqn{c_{s^\dagger}}{c_{s^dag}} est le vecteur des coefficients d'altérabilité de \eqn{s^\dagger}{s^dag},
en définissant \eqn{0^0 = 1}.
\item \eqn{\Omega_e} est une matrice \eqn{T \times T}{T x T} avec les éléments \eqn{\omega_{e_{i,j}} = \rho^{|i-j|}} représentant
l'autocorrelation d'un processus AR(1), en définissant encore \eqn{0^0 = 1}.
\item \eqn{\varepsilon \sim (0, V_\varepsilon)}{epsilon ~ (0, V_epsilon)} est le vecteur des erreurs de mesure des étalons
\eqn{a} avec matrice de covariance \eqn{V_\varepsilon = \mathrm{diag} \left( c_a a \right)}{V_epsilion = diag(c_a a)} où
\eqn{c_a} est le vecteur des coefficients d'altérabilité des étalons \eqn{a}.
}

La solution des moindres carrés généralisés est la suivante :
\deqn{\displaystyle 
\hat{\theta} = s^\dagger + V_e J^{\mathrm{T}} \left( J V_e J^{\mathrm{T}} + V_\varepsilon \right)^+ \left( a - J s^\dagger \right)
}{theta^hat = s^dag + V_e J' (J V_e J' + V_epsilion)^{+} (a - J s^dag)}
où \eqn{A^{+}} désigne l'inverse de Moore-Penrose de la matrice \eqn{A}.

Lorsque \eqn{\rho = 1}, la fonction renvoie la solution de la méthode de Denton (modifiée) :
\deqn{\displaystyle 
\hat{\theta} = s + W \left( a - J s \right)
}{theta^hat = s + W (a - J s)}
où
\itemize{
\item \eqn{W} est la matrice du coin supérieur droit du produit matriciel suivant
\deqn{
    \left[\begin{array}{cc}
      D^{+} \Delta^{\mathrm{T}} \Delta D^{+} & J^{\mathrm{T}} \\
      J & 0
    \end{array} \right]^{+}
    \left[\begin{array}{cc}
      D^{+} \Delta^{\mathrm{T}} \Delta D^{+} & 0 \\
      J & I_M
    \end{array} \right] = 
    \left[\begin{array}{cc}
      I_T & W \\
      0 & W_\nu
    \end{array} \right]
  }{[D^{+} Delta' Delta D^{+}, J'; J, 0]^{+} [D^{+} Delta' Delta D^{+}, 0; J, I_M] = [I_T, W; 0, W_nu]}
\item \eqn{D = \mathrm{diag} \left( \left| s \right|^\lambda \right)}{D = diag(|s|^\lambda)}, en définissant \eqn{0^0 = 1}. Notez
que \eqn{D} correspond à \eqn{C} avec \eqn{c_{s^\dagger} = 1.0}{c_{s^dag} = 1.0} et sans correction de biais (arguments
\code{bias_option = 1} et \code{bias = NA}).
\item \eqn{\Delta}{Delta} est une matrice \eqn{T-1 \times T}{T-1 x T} avec les éléments \eqn{\delta_{i,j} = \left\{
    \begin{array}{cl}
      -1 & \text{si } i=j \\
      1 & \text{si } j=i+1 \\
      0 & \text{sinon}
    \end{array} \right.
  }{delta_{i,j} = 1 si i = j, delta_{i,j} = 1 si j = i + 1, delta_{i,j} = 0 sinon}.
\item \eqn{W_\nu} est une matrice \eqn{M \times M}{M x M} associée aux multiplicateurs de Lagrange du problème de minimisation
correspondant exprimé comme suit :
\deqn{\displaystyle 
\begin{aligned}
& \underset{\theta}{\text{minimiser}} 
& & \sum_{t \ge 2} \left[ \frac{\left( s_t - \theta_t \right)}{\left| s_t\right|^\lambda}
      - \frac{\left( s_{t-1} - \theta_{t-1} \right)}{\left| s_{t-1}\right|^\lambda} \right]^2 \\
& \text{sous contrainte(s)} 
& & a = J \theta
\end{aligned}
}{min(theta) sum_{t>1}{[(s_t - theta_t) / |s_t|^lambda - (s_{t-1} - theta_{t-1}) / |s_{t-1}|^lambda]^2}, sous contrainte(s) 
a = J theta}
}

Voir Quenneville et al. (2006) et Dagum and Cholette (2006) pour les détails.
\subsection{Paramètre autorégressif \eqn{\rho} et le \emph{biais}}{

Le paramètre \eqn{\rho} (argument \code{rho}) est associé au changement entre la série indicatrice (d'entrée) et la série étalonnée
(de sortie) pour deux périodes consécutives et est souvent appelé \emph{paramètre de préservation du mouvement}. Plus la valeur de
\eqn{\rho} est grande, plus les mouvements d'une période à l'autre de la série indicatrice sont préservés dans la série étalonnée.
Avec \eqn{\rho = 0}, la préservation des mouvements d'une période à l'autre n'est pas appliquée et les ajustements d'étalonnage
qui en résultent ne sont pas lisses, comme dans le cas du prorata (\eqn{\rho = 0} et \eqn{\lambda = 0.5}) où les ajustements
prennent la forme d'une \emph{fonction en escalier}. À l'autre extrémité du spectre on trouve \eqn{\rho = 1}, appelé
\emph{étalonnage de Denton}, où la préservation du mouvement d'une période à l'autre est maximisée, ce qui se traduit par l'ensemble
le plus lisse possible d'ajustements d'étalonnage disponibles avec la fonction.

Le \emph{biais} représente l'écart attendu entre les étalons et la série indicatrice. Il peut être utilisé pour pré-ajuster
la série indicatrice afin de réduire, en moyenne, les écarts entre les deux sources de données. La correction du biais, qui est
spécifiée avec les arguments \code{biasOption} et \code{bias}, peut être particulièrement utile pour les périodes non couvertes par les
étalons lorsque \eqn{\rho < 1}. Dans ce contexte, le paramètre \eqn{\rho} dicte la vitesse à laquelle les ajustements
d'étalonnage projetés convergent vers le biais (ou convergent vers \emph{aucun ajustement} sans correction du biais) pour les périodes
non couvertes par un étalon. Plus la valeur de \eqn{\rho} est petite, plus la convergence vers le biais est rapide, avec
convergence immédiate lorsque \eqn{\rho = 0} et aucune convergence (l'ajustement de la dernière période couverte par un étalon
est répété indéfiniment) lorsque \eqn{\rho = 1} (étalonnage de Denton). En fait, les arguments \code{biasOption} et \code{bias} ne sont
pas utilisés lorsque \eqn{\rho = 1} puisque la correction du biais n'a pas d'impact sur les résultats de l'étalonnage de Denton.
La valeur suggérée pour \eqn{\rho} est \eqn{0.9} pour les indicateurs mensuels et \eqn{0.9^3 = 0.729} pour les indicateurs
trimestriels, ce qui représente un compromis raisonnable entre maximiser la préservation du mouvement et réduire les révisions
à mesure que de nouveaux étalons deviendront disponibles à l'avenir (\emph{problème d'actualité} de l'étalonnage). En pratique, il
convient de noter que l'étalonnage de Denton pourrait être \emph{approximé} avec le modèle basé sur la régression en utilisant une
valeur de \eqn{\rho} inférieure à, mais très proche de \eqn{1.0} (par exemple, \eqn{\rho = 0.999}). Voir Dagum et Cholette (2006)
pour une discussion complète sur ce sujet.
}

\subsection{Coefficients d'altérabilité}{

Les coefficients d'altérabilité \eqn{c_{s^\dagger}}{c_{s^dag}} et \eqn{c_a} représentent conceptuellement les erreurs de mesure
associées aux valeurs de la série indicatrice (corrigée pour le biais) \eqn{s^\dagger}{s^dag} et des étalons \eqn{a}
respectivement. Il s'agit de nombres réels non négatifs qui, en pratique, spécifient l'ampleur de la modification permise d'une
valeur initiale par rapport aux autres valeurs. Un coefficient d'altérabilité de \eqn{0.0} définit une valeur fixe
(contraignante), tandis qu'un coefficient d'altérabilité supérieur à \eqn{0.0} définit une valeur libre (non contraignante).
L'augmentation du coefficient d'altérabilité d'une valeur initiale entraîne davantage de changements pour cette valeur dans la
solution d'étalonnage et, inversement, moins de changements lorsque l'on diminue le coefficient d'altérabilité. Les coefficients
d'altérabilité par défaut sont \eqn{0.0} pour les étalons (contraignants) et \eqn{1.0} pour les valeurs de la série indicatrice
(non contraignantes). Remarques importantes :
\itemize{
\item Avec une valeur de \eqn{\rho = 1} (argument \code{rho = 1}, associé à l'étalonnage de Denton), seuls les coefficients
d'altérabilité par défaut (\eqn{0.0} pour un étalon et \eqn{1.0} pour une valeur de série indicatrice) sont valides. La
spécification de variables de coefficients d'altérabilité définies par l'utilisateur n'est donc pas autorisée. Si de telles
variables sont spécifiées (voir les arguments \code{var} et \code{with}), la fonction les ignore et affiche un message d'avertissement
dans la console.
\item Les coefficients d'altérabilité \eqn{c_{s^\dagger}}{c_{s^dag}} entrent en jeu après que la série indicatrice ait été corrigée
pour le biais, lorsqu'applicable (\eqn{c_{s^\dagger}}{c_{s^dag}} est associé à \eqn{s^\dagger}{s^dag} et non à \eqn{s}). Cela
signifie que la spécification d'un coefficient d'altérabilité de \eqn{0.0} pour une valeur de série indicatrice donnée
\strong{ne se traduira pas} par une valeur inchangée après étalonnage \strong{avec correction du biais} (voir les arguments \code{biasOption}
et \code{bias}).
}

Les étalons non contraignants, le cas échéant, peuvent être récupérés (calculés) à partir de la série étalonnée (voir le
\emph{data frame} de sortie \strong{series} dans la section \strong{Valeur de retour}). Le \emph{data frame} de sortie \strong{benchmarks} contient
toujours les étalons fournis dans le \emph{data frame} d'entrée des étalons (argument \code{benchmarks_df}).
}

\subsection{Étalonnage de plusieurs séries}{

Plusieurs séries peuvent être étalonnées en un seul appel à \code{\link[=benchmarking]{benchmarking()}}, en spécifiant \code{allCols = TRUE}, en spécifiant
(manuellement) plusieurs variables avec l'argument \code{var} (et l'argument \code{with}) ou avec le traitement groupes-BY (argument
\code{by != NULL}). Une distinction importante est que toutes les séries indicatrices spécifiées avec \code{allCols = TRUE}  ou avec
l'argument \code{var} (et les étalons avec l'argument \code{with}) doivent avoir la même longueur, c'est-à-dire le même ensemble de
périodes et et le même ensemble (nombre) d'étalons. L'étalonnage de séries de longueurs différentes (différents ensembles
de périodes) ou avec différents ensembles (nombres) d'étalons doit être effectué avec un traitement groupes-BY sur des données
empilées pour les \emph{data frames} d'entrée de séries indicatrices et d'étalons (voir les fonctions utilitaires \code{\link[=stack_tsDF]{stack_tsDF()}}
et \code{\link[=stack_bmkDF]{stack_bmkDF()}}). Les arguments \code{by} et \code{var} peuvent être combinés afin d'implémenter le traitement groupes-BY pour des
séries multiples comme illustré par l'\emph{Exemple 2} dans la section \strong{Exemples}. Alors que l'utilisation de variables multiples
avec 'argument \code{var} (ou \code{allCols = TRUE}) sans traitement groupes-BY (argument \code{by = NULL}) est légèrement plus efficace
(plus rapide), une approche groupes-BY avec une seule variable de série est généralement recommandée car elle est plus générale
(fonctionne dans tous les contextes). Cette dernière est illustrée par l'\emph{Exemple 3} dans la section \strong{Exemples}. Les
variables BY spécifiées avec l'argument \code{by} apparaissent dans les trois \emph{data frames} de sortie.
}

\subsection{Arguments \code{constant} et \code{negInput_option}}{

Ces arguments permettent d'étendre l'utilisation de l'étalonnage proportionnel à un plus grand nombre de problèmes. Leurs
valeurs par défaut correspondent au comportement de G-Séries 2.0 (SAS\eqn{^\circledR}{®} PROC BENCHMARKING) pour lequel des
options équivalentes ne sont pas définies. Bien que l'étalonnage proportionnel ne soit pas nécessairement l'approche la plus
appropriée (l'étalonnage additif pourrait être plus indiqué) lorsque les valeurs de la série indicatrice approchent de 0 (ratios
d'une période à l'autre instables) ou « traversent la ligne de 0 » et peuvent donc passer de positives à négatives et vice-versa
(ratios d'une période à l'autre difficiles à interpréter), ces cas ne sont pas invalides d'un point de vue mathématique (le
problème d'étalonnage proportionnel associé peut être résolu). Il est toutefois fortement recommandé d'analyser et de valider
soigneusement les données étalonnées obtenues dans ces situations pour s'assurer qu'elles correspondent à des solutions
raisonnables et interprétables.
}

\subsection{Traitement des valeurs manquantes (\code{NA})}{
\itemize{
\item Si une valeur manquante apparaît dans l'une des variables du \emph{data frame} d'entrée des étalons (autre que les variables
BY), les enregistrements avec les valeurs manquantes sont laissés de côté, un message d'avertissement est affiché et la
fonction s'exécute.
\item Si une valeur manquante apparaît dans les variables \code{year} ou \code{period} du \emph{data frame} d'entrée des séries indicatrices
et que des variables BY sont spécifiées, le groupe-BY correspondant est ignoré, un message d'avertissement s'affiche et la
fonction passe au groupe-BY suivant. Si aucune variable BY n'est spécifiée, un message d'avertissement s'affiche
et aucun traitement n'est effectué.
\item Si une valeur manquante apparaît dans l'une des variables des données de série du \emph{data frame} d'entrée des séries
indicatrices et que des variables BY sont spécifiées, le groupe-BY correspondant est ignoré, un message d'avertissement est
affiché et la fonction passe au groupe-BY suivant. Si aucune variable BY n'est spécifiée, la série indicatrice concernée
n'est pas traitée, un message d'avertissement est affiché et la fonction passe à la série indicatrice suivante (le cas échéant).
}
}
}
\examples{
# Définir le répertoire de travail (pour les fichiers graphiques PDF)
rep_ini <- getwd() 
setwd(tempdir())


###########
# Exemple 1 : Cas simple d'étalonnage d'une série trimestrielle à des valeurs annuelles

# Série indicatrice trimestrielle
mes_ind1 <- ts_to_tsDF(ts(c(1.9, 2.4, 3.1, 2.2, 2.0, 2.6, 3.4, 2.4, 2.3),
                          start = c(2015, 1),
                          frequency = 4))
mes_ind1

# Étalons annuels pour données trimestrielles
mes_eta1 <- ts_to_bmkDF(ts(c(10.3, 10.2),
                           start = 2015,
                           frequency = 1),
                        ind_frequency = 4)
mes_eta1

# Étalonnage avec...
#   - valeur de `rho` recommandée pour des séries trimestrielles (`rho = 0.729`)
#   - modèle proportionnel (`lambda = 1`)
#   - correction de la série indicatrice pour le biais avec estimation du biais 
#     (`biasOption = 3`)
res_eta1 <- benchmarking(mes_ind1,
                         mes_eta1,
                         rho = 0.729,
                         lambda = 1,
                         biasOption = 3)

# Générerer les graphiques d'étalonnage
plot_graphTable(res_eta1$graphTable, "Graphs_ex1.pdf")


###########
# Exemple 2 : Étalonnage de deux séries trimestrielles à des valeurs annuelles,
#             avec groupes-BY et coef. d'altérabilité définis par l'utilisateur.

# Données sur les ventes (mêmes ventes pour les groupes A et B; seuls les coef. 
# d'alté. pour les ventes de camionnettes diffèrent)
ventes_tri <- ts(matrix(c(# Voitures
                          1851, 2436, 3115, 2205, 1987, 2635, 3435, 2361, 2183, 2822,
                          3664, 2550, 2342, 3001, 3779, 2538, 2363, 3090, 3807, 2631,
                          2601, 3063, 3961, 2774, 2476, 3083, 3864, 2773, 2489, 3082,
                          # Camionnettes
                          1900, 2200, 3000, 2000, 1900, 2500, 3800, 2500, 2100, 3100,
                          3650, 2950, 3300, 4000, 3290, 2600, 2010, 3600, 3500, 2100,
                          2050, 3500, 4290, 2800, 2770, 3080, 3100, 2800, 3100, 2860),
                        ncol = 2),
                 start = c(2011, 1),
                 frequency = 4,
                 names = c("voitures", "camionnettes"))

ventes_ann <- ts(matrix(c(# Voitures
                          10324, 10200, 10582, 11097, 11582, 11092,
                          # Camionnettes
                          12000, 10400, 11550, 11400, 14500, 16000),
                        ncol = 2),
                 start = 2011,
                 frequency = 1,
                 names = c("voitures", "camionnettes"))

# Séries indicatrices trimestrielles (avec les coef. d'alté. par défaut pour l'instant)
mes_ind2 <- rbind(cbind(data.frame(groupe = rep("A", nrow(ventes_tri)),
                                   alt_cam = rep(1, nrow(ventes_tri))),
                        ts_to_tsDF(ventes_tri)),
                  cbind(data.frame(groupe = rep("B", nrow(ventes_tri)),
                                   alt_cam = rep(1, nrow(ventes_tri))),
                        ts_to_tsDF(ventes_tri)))

# Ventes contraignantes de camionnettes (coef. d'alté. = 0) pour 2012 T1 et T2 
# dans le groupe A (lignes 5 et 6)
mes_ind2$alt_cam[c(5,6)] <- 0
head(mes_ind2, n = 10)
tail(mes_ind2)

# Étalons annuels pour données trimestrielles (sans coef. d'alté.)
mes_eta2 <- rbind(cbind(data.frame(groupe = rep("A", nrow(ventes_ann))),
                        ts_to_bmkDF(ventes_ann, ind_frequency = 4)),
                  cbind(data.frame(groupe = rep("B", nrow(ventes_ann))),
                        ts_to_bmkDF(ventes_ann, ind_frequency = 4)))
mes_eta2

# Étalonnage avec...
#   - valeur de `rho` recommandée pour des séries trimestrielles (`rho = 0.729`)
#   - modèle proportionnel (`lambda = 1`)
#   - sans correction du biais (`biasOption = 1` et `bias` non spécifié)
#   - `quiet = TRUE` afin d'éviter l'affichage de l'en-tête de la fonction
res_eta2 <- benchmarking(mes_ind2,
                         mes_eta2,
                         rho = 0.729,
                         lambda = 1,
                         biasOption = 1,
                         var = c("voitures", "camionnettes / alt_cam"),
                         with = c("voitures", "camionnettes"),
                         by = "groupe",
                         quiet = TRUE)

# Générerer les graphiques d'étalonnage
plot_graphTable(res_eta2$graphTable, "Graphs_ex2.pdf")

# Vérifier la valeur des ventes de camionnettes pour 2012 T1 et T2 
# dans le groupe A (valeurs fixes)
all.equal(mes_ind2$camionnettes[c(5,6)], res_eta2$series$camionnettes[c(5,6)])


###########
# Exemple 3 : identique à l'exemple 2, mais en étalonnant les 4 séries 
#             en tant que groupes-BY (4 groupes-BY au lieu de 2)

ventes_tri2 <- ts.union(A = ventes_tri, B = ventes_tri)
mes_ind3 <- stack_tsDF(ts_to_tsDF(ventes_tri2))
mes_ind3$alter <- 1
mes_ind3$alter[mes_ind3$series == "A.camionnettes"
                & mes_ind3$year == 2012 & mes_ind3$period <= 2] <- 0
head(mes_ind3)
tail(mes_ind3)

ventes_ann2 <- ts.union(A = ventes_ann, B = ventes_ann)
mes_eta3 <- stack_bmkDF(ts_to_bmkDF(ventes_ann2, ind_frequency = 4))
head(mes_eta3)
tail(mes_eta3)

res_eta3 <- benchmarking(mes_ind3,
                         mes_eta3,
                         rho = 0.729,
                         lambda = 1,
                         biasOption = 1,
                         var = "value / alter",
                         with = "value",
                         by = "series",
                         quiet = TRUE)

# Générerer les graphiques d'étalonnage
plot_graphTable(res_eta3$graphTable, "Graphs_ex3.pdf")

# Convertir le « data frame » `res_eta3$series` en un objet « mts »
ventes_tri2_eta <- tsDF_to_ts(unstack_tsDF(res_eta3$series), frequency = 4)

# Afficher les 10 premières observations
ts(ventes_tri2_eta[1:10, ], start = start(ventes_tri2), deltat = deltat(ventes_tri2))

# Vérifier la valeur des ventes de camionnettes pour 2012 T1 et T2 
# dans le groupe A (valeurs fixes)
all.equal(window(ventes_tri2[, "A.camionnettes"], start = c(2012, 1), end = c(2012, 2)),
          window(ventes_tri2_eta[, "A.camionnettes"], start = c(2012, 1), end = c(2012, 2)))


# Réinitialiser le répertoire de travail à son emplacement initial
setwd(rep_ini)
}
\references{
Dagum, E. B. et P. Cholette (2006). \strong{Benchmarking, Temporal Distribution and Reconciliation
Methods of Time Series}. Springer-Verlag, New York, Lecture Notes in Statistics, Vol. 186

Fortier, S. et B. Quenneville (2007). « Theory and Application of Benchmarking in Business Surveys ».
\strong{Proceedings of the Third International Conference on Establishment Surveys (ICES-III)}. Montréal, juin 2007.

Latendresse, E., M. Djona et S. Fortier (2007). « Benchmarking Sub-Annual Series to Annual Totals –
From Concepts to SAS\eqn{^\circledR}{®} Procedure and Enterprise Guide\eqn{^\circledR}{®} Custom Task ». \strong{Proceedings
of the SAS\eqn{^\circledR}{®} Global Forum 2007 Conference}. Cary, NC: SAS Institute Inc.

Quenneville, B., S. Fortier, Z.-G. Chen et E. Latendresse (2006). « Recent Developments in Benchmarking to
Annual Totals in X-12-ARIMA and at Statistics Canada ». \strong{Proceedings of the Eurostat Conference on Seasonality,
Seasonal Adjustment and Their Implications for Short-Term Analysis and Forecasting}. Luxembourg, mai 2006.

Quenneville, B., P. Cholette, S. Fortier et J. Bérubé (2010). « Benchmarking Sub-Annual Indicator
Series to Annual Control Totals (Forillon v1.04.001) ». \strong{Document interne}. Statistique Canada, Ottawa, Canada.

Quenneville, B. et S. Fortier (2012). « Restoring Accounting Constraints in Time Series – Methods and
Software for a Statistical Agency ». \strong{Economic Time Series: Modeling and Seasonality}. Chapman & Hall, New York.

Statistique Canada (2012). \strong{Théorie et application de l’étalonnage (Code du cours 0436)}.
Statistique Canada, Ottawa, Canada.

Statistique Canada (2016). « La procédure BENCHMARKING ». \strong{Guide de l'utilisateur de G-Séries 2.0}.
Statistique Canada, Ottawa, Canada.
}
\seealso{
\code{\link[=stock_benchmarking]{stock_benchmarking()}} \code{\link[=plot_graphTable]{plot_graphTable()}} \link{bench_graphs} \code{\link[=plot_benchAdj]{plot_benchAdj()}} \code{\link[=gs.gInv_MP]{gs.gInv_MP()}} \link{aliases}
}
