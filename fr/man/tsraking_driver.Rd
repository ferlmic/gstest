% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsraking_driver.R
\name{tsraking_driver}
\alias{tsraking_driver}
\title{Fonction d'assistance pour \code{\link[=tsraking]{tsraking()}}}
\usage{
tsraking_driver(
  in_ts,
  ...,  # arguments de `tsraking()` excluant `data_df`
  temporal_grp_periodicity = 1,
  temporal_grp_start = 1
)
}
\arguments{
\item{in_ts}{(obligatoire)

Objet de type série chronologique (« ts » ou « mts »), ou objet compatible, qui contient les données des séries
chronologiques à réconcilier. Il s'agit des données d'entrée (solutions initiales) des problèmes de ratissage
(« \emph{raking} »).}

\item{...}{
  Arguments transmis à \code{\link[=tsraking]{tsraking}}
  \describe{
    \item{\code{metadata_df}}{(obligatoire)

\emph{Data frame}, ou objet compatible, qui décrit les contraintes d'agrégation transversales (règles d'additivité) pour le
problème de ratissage (« \emph{raking} »). Deux variables de type caractère doivent être incluses dans le \emph{data frame} :
\code{series} et \code{total1}. Deux variables sont optionnelles : \code{total2} (caractère) et \code{alterAnnual} (numérique). Les valeurs
de la variable \code{series} représentent les noms des variables des séries composantes dans le \emph{data frame} des données
d'entrée (argument \code{data_df}). De même, les valeurs des variables \code{total1} et \code{total2} représentent les noms des variables
des totaux de contrôle transversaux de 1\if{html}{\out{<sup>}}ère\if{html}{\out{</sup>}} et 2\if{html}{\out{<sup>}}ème\if{html}{\out{</sup>}} dimension dans le \emph{data frame} des données
d'entrée. La variable \code{alterAnnual} contient le coefficient d'altérabilité pour la contrainte temporelle associée à
chaque série composante. Lorsqu'elle est spécifiée, cette dernière remplace le coefficient d'altérabilité par défaut
spécifié avec l'argument \code{alterAnnual}.}
    \item{\code{alterability_df}}{(optionnel)

\emph{Data frame}, ou objet compatible, ou \code{NULL}, qui contient les variables de coefficients d'altérabilité. Elles
doivent correspondre à une série composante ou à un total de contrôle transversal, c'est-à-dire qu'une variable
portant le même nom doit exister dans le \emph{data frame} des données d'entrée (argument \code{data_df}). Les valeurs de
ces coefficients d'altérabilité remplaceront les coefficients d'altérabilité par défaut spécifiés avec les arguments
\code{alterSeries}, \code{alterTotal1} et \code{alterTotal2}. Lorsque le \emph{data frame} des données d'entrée contient plusieurs
enregistrements et que le \emph{data frame} des coefficients d'altérabilité n'en contient qu'un seul, les coefficients
d'altérabilité sont utilisés (répétés) pour tous les enregistrements du \emph{data frame} des données d'entrée. Le
\emph{data frame} des coefficients d'altérabilité peut également contenir autant d'enregistrements que le \emph{data frame}
des données d'entrée.

\strong{La valeur par défaut} est \code{alterability_df = NULL} (coefficients d'altérabilité par défaut).}
    \item{\code{alterSeries}}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut pour les valeurs des séries composantes.
Il s'appliquera aux séries composantes pour lesquelles des coefficients d'altérabilité n'ont pas déjà été spécifiés
dans le \emph{data frame} des coefficients d'altérabilité (argument \code{alterability_df}).

\strong{La valeur par défaut} est \code{alterSeries = 1.0} (valeurs des séries composantes non contraignantes).}
    \item{\code{alterTotal1}}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut pour les totaux de contrôle transversaux
de la 1\if{html}{\out{<sup>}}ère\if{html}{\out{</sup>}} dimension. Il s'appliquera aux totaux de contrôle transversaux pour lesquels des coefficients
d'altérabilité n'ont pas déjà été spécifiés dans le \emph{data frame} des coefficients d'altérabilité (argument
\code{alterability_df}).

\strong{La valeur par défaut} est \code{alterTotal1 = 0.0} (totaux de contrôle transversaux de 1\if{html}{\out{<sup>}}ère\if{html}{\out{</sup>}} dimension
contraignants).}
    \item{\code{alterTotal2}}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut pour les totaux de contrôle transversaux
de la 2\if{html}{\out{<sup>}}ème\if{html}{\out{</sup>}} dimension. Il s'appliquera aux totaux de contrôle transversaux pour lesquels des coefficients
d'altérabilité n'ont pas déjà été spécifiés dans le \emph{data frame} des coefficients d'altérabilité (argument
\code{alterability_df}).

\strong{La valeur par défaut} est \code{alterTotal2 = 0.0} (totaux de contrôle transversaux de 2\if{html}{\out{<sup>}}ème\if{html}{\out{</sup>}} dimension
contraignants).}
    \item{\code{alterAnnual}}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut pour les contraintes temporelles
(ex., totaux annuels) des séries composantes. Il s'appliquera aux séries composantes pour lesquelles des
coefficients d'altérabilité n'ont pas déjà été spécifiés dans le \emph{data frame} des métadonnées de ratissage
(argument \code{metadata_df}).

\strong{La valeur par défaut} est \code{alterAnnual = 0.0} (totaux de contrôle temporels contraignants).}
    \item{\code{tolV,tolP}}{(optionnel)

Nombre réel non négatif, ou \code{NA}, spécifiant la tolérance, en valeur absolue ou en pourcentage, à utiliser
lors du test ultime pour les totaux de contrôle contraignants (coefficient d'altérabilité de \eqn{0.0} pour
les totaux de contrôle temporels ou transversaux). Le test compare les totaux de contrôle contraignants d'entrée
avec ceux calculés à partir des séries composantes réconciliées (en sortie). Les arguments \code{tolV} et \code{tolP} ne
peuvent pas être spécifiés tous les deux à la fois (l'un doit être spécifié tandis que l'autre doit être \code{NA}).

\strong{Exemple :} pour une tolérance de 10 \emph{unités}, spécifiez \verb{tolV = 10, tolP = NA}; pour une tolérance de 1\%,
spécifiez \verb{tolV = NA, tolP = 0.01}.

\strong{Les valeurs par défaut} sont \code{tolV = 0.001} et \code{tolP = NA}.}
    \item{\code{warnNegResult}}{(optionnel)

Argument logique (\emph{logical}) spécifiant si un message d'avertissement doit être affiché lorsqu'une valeur négative
créée par la fonction dans une série réconciliée (en sortie) est inférieure au seuil spécifié avec l'argument \code{tolN}.

\strong{La valeur par défaut} est \code{warnNegResult = TRUE}.}
    \item{\code{tolN}}{(optionnel)

Nombre réel négatif spécifiant le seuil pour l'identification des valeurs négatives. Une valeur est considérée
négative lorsqu'elle est inférieure à ce seuil.

\strong{La valeur par défaut} est \code{tolN = -0.001}.}
    \item{\code{id}}{(optionnel)

Vecteur de chaînes de caractère (longueur minimale de 1), ou \code{NULL}, spécifiant le nom des variables additionnelles
à transférer du \emph{data frame} d'entrée (argument \code{data_df}) au \emph{data frame} de sortie, c.-à-d., l'objet renvoyé par
la fonction (voir la section \strong{Valeur de retour}). Par défaut, le \emph{data frame} de sortie ne contient que les
variables énumérées dans le \emph{data frame} des métadonnées de ratissage (argument \code{metadata_df}).

\strong{La valeur par défaut} est \code{id = NULL}.}
    \item{\code{verbose}}{(optionnel)

Argument logique (\emph{logical}) spécifiant si les informations sur les étapes intermédiaires avec le temps d'exécution
(temps réel et non le temps CPU) doivent être affichées. Notez que spécifier l'argument \code{quiet = TRUE} annulerait
l'argument \code{verbose}.

\strong{La valeur par défaut} est \code{verbose = FALSE}.}
    \item{\code{Vmat_option}}{(optionnel)

Spécification de l'option pour les matrices de variance (\eqn{V_e} et \eqn{V_\epsilon}; voir la section \strong{Détails}) :\tabular{cl}{
   \strong{Valeur} \tab \strong{Description} \cr
   \code{1} \tab Utiliser les vecteurs \eqn{x} et \eqn{g} dans les matrices de variance. \cr
   \code{2} \tab Utiliser les vecteurs \eqn{|x|} et \eqn{|g|} dans les matrices de variance. \cr
}


Voir Ferland (2016) et la sous-section \strong{Arguments \code{Vmat_option} et \code{warnNegInput}} dans la section \strong{Détails} pour
plus d'informations.

\strong{La valeur par défaut} est \code{Vmat_option = 1}.}
    \item{\code{warnNegInput}}{(optionnel)

Argument logique (\emph{logical}) spécifiant si un message d'avertissement doit être affiché lorsqu'une valeur négative
plus petite que le seuil spécifié par l'argument \code{tolN} est trouvée dans le \emph{data frame} des données d'entrée
(argument \code{data_df}).

\strong{La valeur par défaut} est \code{warnNegInput = TRUE}.}
    \item{\code{quiet}}{(optionnel)

Argument logique (\emph{logical}) spécifiant s'il faut ou non afficher uniquement les informations essentielles telles
que les messages d'avertissements et d'erreurs. Spécifier \code{quiet = TRUE} annulera également l'argument \code{verbose} et
est équivalent à \emph{envelopper} votre appel à \code{\link[=tsraking]{tsraking()}} avec \code{\link[=suppressMessages]{suppressMessages()}}.

\strong{La valeur par défaut} est \code{quiet = FALSE}.}
  }}

\item{temporal_grp_periodicity}{(optionnel)

Nombre entier positif définissant le nombre de périodes dans les groupes temporels pour lesquels les totaux doivent
être préservés. Par exemple, spécifiez \code{temporal_grp_periodicity = 3} avec des séries chronologiques mensuelles pour la
préservation des totaux trimestriels et \code{temporal_grp_periodicity = 12} (ou \code{temporal_grp_periodicity = frequency(in_ts)})
pour la préservation des totaux annuels. Spécifier \code{temporal_grp_periodicity = 1} (\emph{défaut}) correspond à un traitement
période par période sans préservation des totaux temporels.

\strong{La valeur par défaut} est \code{temporal_grp_periodicity = 1} (traitement période par période sans préservation des
totaux temporels).}

\item{temporal_grp_start}{(optionnel)

Entier dans l'intervalle [1 .. \code{temporal_grp_periodicity}] spécifiant la période (cycle) de départ pour la préservation
des totaux temporels. Par exemple, des totaux annuels correspondant aux années financières définies d'avril à mars de l'année
suivante seraient spécifiés avec \code{temporal_grp_start = 4} pour des séries chronologiques mensuelles (\code{frequency(in_ts) = 12})
et \code{temporal_grp_start = 2} pour des séries chronologiques trimestrielles (\code{frequency(in_ts) = 4}). Cet argument n'a pas
d'effet pour un traitement période par période sans préservation des totaux temporels (\code{temporal_grp_periodicity = 1}).

\strong{La valeur par défaut} est \code{temporal_grp_start = 1}.}
}
\value{
La fonction renvoie un objet de type série chronologique (« ts » ou « mts ») contenant les séries composantes
réconciliées, les totaux de contrôle transversaux réconciliés et d'autres séries spécifiées avec l'argument \code{id} de
\code{\link[=tsraking]{tsraking()}}. Il peut être explicitement converti en un autre type d'objet avec la fonction \verb{as*()} appropriée (ex.,
\code{tsibble::as_tsibble()} le convertirait en tsibble).

Notez qu'un objet \code{NULL} est renvoyé si une erreur survient avant que le traitement des données ne puisse commencer.
Dans le cas contraire, si l'exécution est suffisamment avancée pour que le traitement des données puisse commencer,
alors un objet incomplet (avec des valeurs \code{NA}) sera renvoyé en cas d'erreur.
}
\description{
Fonction d'assistance pour \code{\link[=tsraking]{tsraking()}} qui détermine de manière pratique l'ensemble des problèmes de ratissage
(« \emph{raking} ») à résoudre et génère à l'interne les appels individuels à \code{\link[=tsraking]{tsraking()}}. Cette fonction est particulièrement
utile dans le contexte de la préservation des totaux temporels (ex., totaux annuels) où chaque problème de ratissage
individuel implique une seule période pour les groupes temporels incomplets (ex., années incomplètes) ou plusieurs
périodes pour les groupes temporels complets (ex., l'ensemble des périodes d'une année complète).
}
\details{
Cette fonction résout un problème de ratissage avec \code{\link[=tsraking]{tsraking()}} par groupe de traitement (voir la section \strong{Groupes
de traitement} pour plus de détails). L'expression mathématique de ces problèmes de ratissage peut être trouvée dans
la section \strong{Détails} de la documentation de \code{\link[=tsraking]{tsraking()}}.

Le \emph{data frame} des coefficients d'altérabilité (argument \code{alterability_df}) spécifié avec \code{\link[=tsraking_driver]{tsraking_driver()}} peut soit
contenir :
\itemize{
\item Un seul enregistrement : les coefficients spécifiés seront utilisés pour toutes les périodes de l'objet d'entrée de
type série chronologique (argument \code{in_ts}).
\item Un nombre d'enregistrements égal à \code{frequency(in_ts)} : les coefficients spécifiés seront utilisés pour le \emph{cycle}
correspondant aux périodes de l'objet d'entrée de type série chronologique (argument \code{in_ts}). Exemple pour des données
mensuelles : 1\if{html}{\out{<sup>}}er\if{html}{\out{</sup>}} enregistrement pour janvier, 2\if{html}{\out{<sup>}}ème\if{html}{\out{</sup>}} enregistrement pour février, etc.)
\item Un nombre d'enregistrements égal à \code{nrow(in_ts)} : les coefficients spécifiés seront utilisés pour les périodes
correspondantes de l'objet d'entrée de type série chronologique (argument \code{in_ts}), c.-à-d., 1\if{html}{\out{<sup>}}er\if{html}{\out{</sup>}}
enregistrement pour la 1\if{html}{\out{<sup>}}ère\if{html}{\out{</sup>}} période, 2\if{html}{\out{<sup>}}ème\if{html}{\out{</sup>}} enregistrement pour la 2\if{html}{\out{<sup>}}ème\if{html}{\out{</sup>}} période, etc.
}

Spécifier \code{quiet = TRUE} supprimera les messages de \code{\link[=tsraking]{tsraking()}} (ex., l'en-tête de la fonction) et n'affichera que les
informations essentielles telles que les avertissements, les erreurs et la période (ou l'ensemble des périodes) en cours
de traitement. Nous déconseillons d'\emph{envelopper} l'appel à la fonction \code{\link[=tsraking_driver]{tsraking_driver()}} avec \code{\link[=suppressMessages]{suppressMessages()}} pour
supprimer l'affichage des informations relatives à la (aux) période(s) en cours de traitement, car cela rendrait
difficile le dépannage de problèmes de ratissage individuels.

Bien que \code{\link[=tsraking]{tsraking()}} puisse être appelée avec \verb{*apply()} pour réconcilier successivement toutes les périodes de l'objet
d'entrée de type série chronologique (argument \code{in_ts}), l'utilisation de \code{\link[=tsraking_driver]{tsraking_driver()}} présente quelques avantages,
notamment :
\itemize{
\item la préservation des totaux temporels (seul un traitement période par période, sans préservation des totaux temporels,
serait possible avec \verb{*apply()});
\item une plus grande flexibilité dans la spécification des coefficients d'altérabilité définis par l'utilisateur (ex., des
valeurs spécifiques aux périodes);
\item affichage de la période en cours de traitement dans la console, ce qui est utile pour dépanner les problèmes de
ratissage individuels;
\item amélioration de la gestion des erreurs, c.-à-d., une meilleure gestion des avertissements ou des erreurs s'ils ne se
produisent que pour certains problèmes de ratissage (périodes);
\item renvoi automatique d'un objet de type « ts » (« mts »).
}
}
\section{Groupes de traitement}{
L'ensemble des périodes d'un problème de réconciliation (ratissage ou équilibrage) donné est appelé \emph{groupe de
traitement} et correspond soit :
\itemize{
\item à une \strong{période unique} lors d'un traitement période par période ou, lorsque les totaux temporels sont préservés,
pour les périodes individuelles d'un groupe temporel incomplet (ex., une année incomplète)
\item ou à l'\strong{ensemble des périodes d'un groupe temporel complet} (ex., une année complète) lorsque les totaux temporels
sont préservés.
}

Le nombre total de groupes de traitement (nombre total de problèmes de réconciliation) dépend de l'ensemble de périodes
des séries chronologiques d'entrée (objet de type série chronologique spécifié avec l'argument \code{in_ts}) et de la valeur
des arguments \code{temporal_grp_periodicity} et \code{temporal_grp_start}.

Les scénarios courants incluent \code{temporal_grp_periodicity = 1} (par défaut) pour un traitement période par période sans
préservation des totaux temporels et \ifelse{latex}{\code{temporal_grp_periodicity = freq uency(in_ts)}}{
\code{temporal_grp_periodicity = frequency(in_ts)}} pour la préservation des totaux annuels (années civiles par défaut).
L'argument \code{temporal_grp_start} permet de spécifier d'autres types d'années (\emph{non civile}). Par exemple, des années
financières commençant en avril correspondent à \code{temporal_grp_start = 4} avec des données mensuelles et à
\code{temporal_grp_start = 2} avec des données trimestrielles. La préservation des totaux trimestriels avec des données
mensuelles correspondrait à \code{temporal_grp_periodicity = 3}.

Par défaut, les groupes temporels convrant plus d'une année (c.-à-d., correspondant à \ifelse{latex}{\code{
temporal_grp _periodicity > frequency(in_ts)}}{\code{temporal_grp_periodicity > frequency(in_ts)}}) débutent avec une année
qui est un multiple de \ifelse{latex}{\code{ceiling( temporal_grp_periodicity / frequency(in_ts))}}{\code{
ceiling(temporal_grp_periodicity / frequency(in_ts))}}. Par exemple, les groupes bisannuels correspondant à
\code{temporal_grp_periodicity = 2 * frequency(in_ts)} débutent avec une \emph{année paire} par défaut. Ce comportement peut être
modifié avec l'argument \code{temporal_grp_start}. Par exemple, la préservation des totaux bisannuels débutant avec une \emph{année
impaire} au lieu d'une \emph{année paire} (par défaut) correspond à \code{temporal_grp_start = frequency(in_ts) + 1} (avec
\ifelse{latex}{\code{temporal_grp _periodicity = 2 * frequency(in_ts)}}{\code{temporal_grp_periodicity = 2 * frequency(in_ts)}}).

Voir les \strong{Exemples} de \code{\link[=gs.build_proc_grps]{gs.build_proc_grps()}} pour des scénarios courants de groupes de traitements.
}

\examples{
# Problème de ratissage à 1 dimension où les ventes trimestrielles de voitures 
# dans les 3 provinces des Prairies (Alb., Sask. et Man.) pour 8 trimestres, 
# de 2019 T2 à 2021 T1, doivent être égales au total (`cars_tot`).

# Métadonnées du problème
mes_meta <- data.frame(series = c("autos_alb", "autos_sask", "autos_man"),
                       total1 = rep("autos_tot", 3))
mes_meta

# Données du problème
mes_series <- ts(matrix(c(14, 18, 14, 58,
                          17, 14, 16, 44,
                          14, 19, 18, 58,
                          20, 18, 12, 53,
                          16, 16, 19, 44,
                          14, 15, 16, 50,
                          19, 20, 14, 52,
                          16, 15, 19, 51),
                        ncol = 4,
                        byrow = TRUE,
                        dimnames = list(NULL, c("autos_alb", "autos_sask",
                                                "autos_man", "autos_tot"))),
                 start = c(2019, 2),
                 frequency = 4)


###########
# Exemple 1 : Traitement période-par-période sans préservation des totaux annuels.

# Réconcilier les données
res_ratis1 <- tsraking_driver(mes_series, mes_meta)

# Données initiales
mes_series

# Données réconciliées
res_ratis1

# Vérifier les contraintes transversales en sortie
all.equal(rowSums(res_ratis1[, mes_meta$series]), as.vector(res_ratis1[, "autos_tot"]))

# Vérifier le total de contrôle (fixe)
all.equal(mes_series[, "autos_tot"], res_ratis1[, "autos_tot"])


###########
# Exemple 2 : Préservation des totaux annuels de 2020 (traitement période-par-période 
#             pour les années incomplètes 2019 et 2021), avec `quiet = TRUE` pour 
#             éviter d'afficher l'en-tête de la fonction pour chaque groupe de traitement.

# Vérifions tout d'abord que le total annuel de 2020 de la série totale (`autos_tot`) 
# et de la somme des séries composantes (`autos_alb`, `autos_sask` et `autos_man`) 
# concordent. Dans le cas contraire, il faudrait d'abord résoudre cet écart avant 
# d'exécuter `tsraking_driver()`.
tot2020 <- aggregate.ts(window(mes_series, start = c(2020, 1), end = c(2020, 4)))
all.equal(as.numeric(tot2020[, "autos_tot"]), sum(tot2020[, mes_meta$series]))

# Réconcilier les données
res_ratis2 <- tsraking_driver(in_ts = mes_series,
                              metadata_df = mes_meta,
                              quiet = TRUE,
                              temporal_grp_periodicity = frequency(mes_series))

# Données initiales
mes_series

# Données réconciliées
res_ratis2

# Vérifier les contraintes transversales en sortie
all.equal(rowSums(res_ratis2[, mes_meta$series]), as.vector(res_ratis2[, "autos_tot"]))

# Vérifier les contraintes temporelles en sortie (total annuel de 2020 pour chaque série)
all.equal(tot2020,
          aggregate.ts(window(res_ratis2, start = c(2020, 1), end = c(2020, 4))))

# Vérifier le total de contrôle (fixe)
all.equal(mes_series[, "autos_tot"], res_ratis2[, "autos_tot"])


###########
# Exemple 3 : Préservation des totaux annuels pour les années financières allant  
#             d'avril à mars (2019T2-2020T1 et 2020T2-2021T1).

# Calculer les deux totaux d'années financières (objet « ts » annuel)
tot_annFisc <- ts(rbind(aggregate.ts(window(mes_series,
                                            start = c(2019, 2),
                                            end = c(2020, 1))),
                        aggregate.ts(window(mes_series,
                                            start = c(2020, 2),
                                            end = c(2021, 1)))),
                  start = 2019,
                  frequency = 1)

# Écarts dans les totaux d'années financières (série totale contre la somme des 
# séries composantes)
as.numeric(tot_annFisc[, "autos_tot"]) - rowSums(tot_annFisc[, mes_meta$series])


# 3a) Réconcilier les totaux d'années financières (ratisser les totaux d'années 
#     financières des séries composantes à ceux de la série totale).
tot_annFisc_ratis <- tsraking_driver(in_ts = tot_annFisc,
                                     metadata_df = mes_meta,
                                     quiet = TRUE)

# Confirmer que les écarts précédents ont disparu (ils sont tous les deux nuls).
as.numeric(tot_annFisc_ratis[, "autos_tot"]) - rowSums(tot_annFisc_ratis[, mes_meta$series])

# 3b) Étalonner les séries composantes trimestrielles à ces nouveaux totaux (cohérents) 
#     d'années financières.
res_eta <- benchmarking(series_df = ts_to_tsDF(mes_series[, mes_meta$series]),
                        benchmarks_df = ts_to_bmkDF(
                          tot_annFisc_ratis[, mes_meta$series],
                          ind_frequency = frequency(mes_series),
                          
                          # Années financières d'avril à mars (T2 à T1)
                          bmk_interval_start = 2),
                        
                        rho = 0.729,
                        lambda = 1,
                        biasOption = 2,
                        allCols = TRUE,
                        quiet = TRUE)
mes_series_eta <- tsDF_to_ts(cbind(res_eta$series, autos_tot = mes_series[, "autos_tot"]),
                             frequency = frequency(mes_series))

# 3c) Réconcilier les données trimestrielles en préservant les totaux d'années finiacières.
res_ratis3 <- tsraking_driver(in_ts = mes_series_eta,
                              metadata_df = mes_meta,
                              temporal_grp_periodicity = frequency(mes_series),
                              
                              # Années financières d'avril à mars (T2 à T1)
                              temporal_grp_start = 2,
                              
                              quiet = TRUE)

# Données initiales
mes_series

# Avec totaux d'années finiacières cohérents
mes_series_eta

# Données réconciliées
res_ratis3

# Vérifier les contraintes transversales en sortie
all.equal(rowSums(res_ratis3[, mes_meta$series]), as.vector(res_ratis3[, "autos_tot"]))

# Vérifier les contraintes temporelles en sortie (totaux des deux années financières pour 
# chaque série)
all.equal(rbind(aggregate.ts(window(mes_series_eta, start = c(2019, 2), end = c(2020, 1))),
                aggregate.ts(window(mes_series_eta, start = c(2020, 2), end = c(2021, 1)))),
          rbind(aggregate.ts(window(res_ratis3, start = c(2019, 2), end = c(2020, 1))),
                aggregate.ts(window(res_ratis3, start = c(2020, 2), end = c(2021, 1)))))

# Vérifier le total de contrôle (fixe)
all.equal(mes_series[, "autos_tot"], res_ratis3[, "autos_tot"])
}
\references{
Statistique Canada (2018). "Chapitre : Sujets avancés", \strong{Théorie et application de la réconciliation
(Code du cours 0437)}, Statistique Canada, Ottawa, Canada.
}
\seealso{
\code{\link[=tsraking]{tsraking()}} \code{\link[=tsbalancing]{tsbalancing()}} \code{\link[=rkMeta_to_blSpecs]{rkMeta_to_blSpecs()}} \code{\link[=gs.build_proc_grps]{gs.build_proc_grps()}}
}
