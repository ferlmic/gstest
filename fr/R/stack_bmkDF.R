#' Empiler des « données étalon »
#'
#'
#' @description
#' Convertir un *data frame* d'étalons multivariés (voir [ts_to_bmkDF()]) pour les fonctions d'étalonnage
#' ([benchmarking()] et [stock_benchmarking()]) en un *data frame* empilé (long) avec six variables (colonnes) :
#' * une (1) pour le nom de l'étalon (ex., nom de série)
#' * quatre (4) pour la converture de l'étalon
#' * une (1) pour la valeur de l'étalon
#' 
#' Les valeurs d'étalon manquantes (`NA`) ne sont pas incluses par défaut dans le *data frame* empilé renvoyé par 
#' la fonction. Spécifiez l'argument `keep_NA = TRUE` pour les conserver.
#' 
#' Cette fonction est utile lorsque l'on souhaite utiliser l'argument `by` (mode de traitement *groupes-BY*) des 
#' fonctions d'étalonnage afin d'étalonner plusieurs séries en un seul appel de fonction.
#'
#'
#' @param bmk_df (obligatoire)
#'
#' *Data frame*, ou objet compatible, qui contient les étalons multivariés à empiler.
#'
#' @param ser_cName (optionnel)
#'
#' Chaîne de caractères spécifiant le nom de la variable (colonne) du *data frame* empilé de sortie qui contiendra 
#' les nom des étalons (nom des variables d'étalons dans le *data frame* d'étalons multivariés d'entrée). Cette variable 
#' peut ensuite être utilisée comme variable de groupes-BY (argument `by`) avec les fonctions d'étalonnage.
#'
#' **La valeur par défaut** est `ser_cName = "series"`.
#'
#' @param startYr_cName,startPer_cName,endYr_cName,endPer_cName (optionnel)
#'
#' Chaînes de caractères spécifiant le nom des variables (colonnes) numériques du *data frame* d'étalons multivariés d'entrée 
#' qui définissent la couverture des étalons, c'est-à-dire les identificateurs de l'année et de la période (cycle) de début et 
#' de fin des étalons. Ces variables sont *transférées* dans le *data frame* empilé de sortie avec les mêmes noms de variable.
#'
#' **Les valeurs par défaut** sont `startYr_cName = "startYear"`, `startPer_cName = "startPeriod"`
#' `endYr_cName = "endYear"` et `endPer_Name = "endPeriod"`.
#'
#' @param val_cName (optionnel)
#'
#' Chaîne de caractères spécifiant le nom de la variable (colonne) du *data frame* empilé de sortie qui contiendra 
#' les valeurs des étalons.
#'
#' **La valeur par défaut** est `val_cName = "value"`.
#'
#' @param keep_NA (optionnel)
#'
#' Argument logique (*logical*) spécifiant si les valeurs d'étalon manquantes (`NA`) du *data frame* d'étalons multivariés 
#' d'entrée doivent être conservées dans le *data frame* empilé de sortie.
#'
#' **La valeur par défaut** est `keep_NA = FALSE`.
#'
#'
#' @returns
#' La fonction renvoie un *data frame* avec six variables :
#' * Nom de l'étalon (de la série), type caractère (voir l'argument `ser_cName`)
#' * Année de début de la couverture de l'étalon, type numérique (voir argument `startYr_cName`)
#' * Période de début de la couverture de l'étalon, type numérique (voir argument `startPer_cName`)
#' * Année de fin de la couverture de l'étalon, type numérique (voir argument `endtYr_cName`)
#' * Période de fin de la couverture de l'étalon, type numérique (voir argument `endPer_cName`)
#' * Valeur de l'étalon, type numérique (voir argument `val_cName`)
#'
#' Note : la fonction renvoie un objet « data.frame » qui peut être explicitement converti en un autre 
#' type d'objet avec la fonction `as*()` appropriée (ex., `tibble::as_tibble()` le convertirait en tibble).
#'
#'
#' @seealso [stack_tsDF()] [ts_to_bmkDF()] [benchmarking()] [stock_benchmarking()]
#'
#'
#' @example misc/function_examples/stack_bmkDF-ex.R
#'
#'
#' @export
stack_bmkDF <- function(bmk_df,
                        ser_cName = "series",
                        startYr_cName = "startYear",
                        startPer_cName = "startPeriod",
                        endYr_cName = "endYear",
                        endPer_cName = "endPeriod",
                        val_cName = "value",
                        keep_NA = FALSE) {
  
  # Enforce the default R "error" option (`options(error = NULL)`). E.g. this Turns off traceback
  # generated by calls to the stop() function inside internal functions in R Studio.
  ini_error_opt <- getOption("error")
  on.exit(options(error = ini_error_opt))
  options(error = NULL)
  
  # validate object
  if (!is.data.frame(bmk_df)) {
    stop("Argument 'bmk_df' is not a 'data.frame' object.\n\n", call. = FALSE)
  }
  bmk_df <- as.data.frame(bmk_df)
  df_cols <- names(bmk_df)
  date_cols <- c(startYr_cName, startPer_cName, endYr_cName, endPer_cName)
  date_args <- c("startYr_cName", "startPer_cName", "endYr_cName", "endPer_cName")
  for (ii in seq_along(date_cols)) {
    if (!(date_cols[ii] %in% df_cols)) {
      stop("The input data frame does not contain column \"", date_cols[ii], "\" (argument '",
           date_args[ii], "').\n\n", call. = FALSE)
    }
  }
  
  ser_list <- setdiff(df_cols, date_cols)
  out_df <- data.frame(col1 = character(),
                       col2 = integer(),
                       col3 = integer(),
                       col4 = integer(),
                       col5 = integer(),
                       col6 = double(),
                       stringsAsFactors = FALSE)
  for (ser in ser_list) {
    if (gs.validate_arg_logi(keep_NA)) {
      tmp_df <- bmk_df[c(date_cols, ser)]
    } else {
      tmp_df <- bmk_df[!is.na(bmk_df[ser]), c(date_cols, ser)]
    }
    out_df <- rbind(out_df, data.frame(col1 = ser,
                                       col2 = as.integer(tmp_df[[startYr_cName]]),
                                       col3 = as.integer(tmp_df[[startPer_cName]]),
                                       col4 = as.integer(tmp_df[[endYr_cName]]),
                                       col5 = as.integer(tmp_df[[endPer_cName]]),
                                       col6 = as.numeric(tmp_df[[ser]]),
                                       stringsAsFactors = FALSE))
  }
  
  # Set the column names and reset the now names (numbers)
  names(out_df) <- c(ser_cName, date_cols, val_cName)
  row.names(out_df) <- NULL
  out_df  
}
