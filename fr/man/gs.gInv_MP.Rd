% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils-common.R
\name{gs.gInv_MP}
\alias{gs.gInv_MP}
\title{Inverse de Moore-Penrose}
\usage{
gs.gInv_MP(X, tol = NA)
}
\arguments{
\item{X}{(mandatory)

Matrice à inverser.}

\item{tol}{(optional)

Nombre réel qui spécifie la tolérance pour l'identification des valeurs singulières nulles. Lorsque \code{tol = NA}
(par défaut), la tolérance est calculée comme étant le produit de la taille (dimension) de la matrice, de la norme
de la matrice (plus grande valeur singulière) et de l'\emph{epsilon de la machine} (\code{.Machine$double.eps}).

\strong{Default value} is \code{tol = NA}.}
}
\value{
L'inverse (pseudo inverse) de Moore-Penrose de la matrice \code{X}.
}
\description{
Cette fonction calcule l'inverse (pseudo inverse) de Moore-Penrose d'une matrice carrée ou
rectangulaire en utilisant la décomposition en valeurs singulières (SVD, de l'anglais
\emph{singular value decomposition}). Elle est utlilisée à l'interne par \code{\link[=tsraking]{tsraking()}} et \code{\link[=benchmarking]{benchmarking()}}.
}
\details{
La tolérance utilisée par défaut (argument \code{tol = NA}) est cohérente avec la tolérance utilisée par les logiciels
MATLAB et GNU Octave dans leurs fonctions inverses générales. Lors de nos tests, cette tolérance par défaut a
également produit des solutions (résultats) comparables à G-Series 2.0 en SAS\eqn{^\circledR}{®}.
}
\examples{

# Matrice inversible
X1 <- matrix(c(3, 2, 8, 
               6, 3, 2,
               5, 2, 4), nrow = 3, byrow = TRUE)
Y1 <- gs.gInv_MP(X1)
all.equal(Y1, solve(X1))
X1 \%*\% Y1

# Matrice rectangulaire
X2 <- X1[-1, ]
try(solve(X2))
X2 \%*\% gs.gInv_MP(X2)

# Matrice carrée non inversible
X3 <- matrix(c(3, 0, 0, 
               0, 0, 0, 
               0, 0, 4), nrow = 3, byrow = TRUE)
try(solve(X3))
X3 \%*\% gs.gInv_MP(X3)

}
\seealso{
\code{\link[=tsraking]{tsraking()}} \code{\link[=benchmarking]{benchmarking()}}
}
