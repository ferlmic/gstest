% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsraking.R
\name{build_raking_problem}
\alias{build_raking_problem}
\title{Construire les éléments du problème de ratissage.}
\usage{
build_raking_problem(
  data_df,
  metadata_df,
  data_df_name = deparse1(substitute(data_df)),
  metadata_df_name = deparse1(substitute(metadata_df)),
  alterability_df = NULL,
  alterSeries = 1,
  alterTotal1 = 0,
  alterTotal2 = 0
)
}
\arguments{
\item{data_df}{(obligatoire)

\emph{Data frame}, ou objet compatible, qui contient les données des séries chronologiques à réconcilier. Il doit au minimum
contenir des variables correspondant aux séries composantes et aux totaux de contrôle transversaux spécifiés dans le
\emph{data frame} des métadonnées de ratissage (argument \code{metadata_df}). Si plus d'un enregistrement (plus d'une période) est
fournie, la somme des valeurs des séries composantes fournies sera également préservée à travers des contraintes
temporelles implicites.}

\item{metadata_df}{(obligatoire)

\emph{Data frame}, ou objet compatible, qui décrit les contraintes d'agrégation transversales (règles d'additivité) pour le
problème de ratissage (« \emph{raking} »). Deux variables de type caractère doivent être incluses dans le \emph{data frame} :
\code{series} et \code{total1}. Deux variables sont optionnelles : \code{total2} (caractère) et \code{alterAnnual} (numérique). Les valeurs
de la variable \code{series} représentent les noms des variables des séries composantes dans le \emph{data frame} des données
d'entrée (argument \code{data_df}). De même, les valeurs des variables \code{total1} et \code{total2} représentent les noms des variables
des totaux de contrôle transversaux de 1\if{html}{\out{<sup>}}ère\if{html}{\out{</sup>}} et 2\if{html}{\out{<sup>}}ème\if{html}{\out{</sup>}} dimension dans le \emph{data frame} des données
d'entrée. La variable \code{alterAnnual} contient le coefficient d'altérabilité pour la contrainte temporelle associée à
chaque série composante. Lorsqu'elle est spécifiée, cette dernière remplace le coefficient d'altérabilité par défaut
spécifié avec l'argument \code{alterAnnual}.}

\item{data_df_name}{(optionnel)

Chaîne de caractères contenant la valeur de l'argument \code{data_df}.

\strong{La valeur par défaut} est \code{data_df_name = deparse1(substitute(data_df))}.}

\item{metadata_df_name}{(optionnel)

Chaîne de caractères contenant la valeur de l'argument \code{metadata_df}.

\strong{La valeur par défaut} est \code{data_df_name = deparse1(substitute(metadata_df))}.}

\item{alterability_df}{(optionnel)

\emph{Data frame}, ou objet compatible, ou \code{NULL}, qui contient les variables de coefficients d'altérabilité. Elles
doivent correspondre à une série composante ou à un total de contrôle transversal, c'est-à-dire qu'une variable
portant le même nom doit exister dans le \emph{data frame} des données d'entrée (argument \code{data_df}). Les valeurs de
ces coefficients d'altérabilité remplaceront les coefficients d'altérabilité par défaut spécifiés avec les arguments
\code{alterSeries}, \code{alterTotal1} et \code{alterTotal2}. Lorsque le \emph{data frame} des données d'entrée contient plusieurs
enregistrements et que le \emph{data frame} des coefficients d'altérabilité n'en contient qu'un seul, les coefficients
d'altérabilité sont utilisés (répétés) pour tous les enregistrements du \emph{data frame} des données d'entrée. Le
\emph{data frame} des coefficients d'altérabilité peut également contenir autant d'enregistrements que le \emph{data frame}
des données d'entrée.

\strong{La valeur par défaut} est \code{alterability_df = NULL} (coefficients d'altérabilité par défaut).}

\item{alterSeries}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut pour les valeurs des séries composantes.
Il s'appliquera aux séries composantes pour lesquelles des coefficients d'altérabilité n'ont pas déjà été spécifiés
dans le \emph{data frame} des coefficients d'altérabilité (argument \code{alterability_df}).

\strong{La valeur par défaut} est \code{alterSeries = 1.0} (valeurs des séries composantes non contraignantes).}

\item{alterTotal1}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut pour les totaux de contrôle transversaux
de la 1\if{html}{\out{<sup>}}ère\if{html}{\out{</sup>}} dimension. Il s'appliquera aux totaux de contrôle transversaux pour lesquels des coefficients
d'altérabilité n'ont pas déjà été spécifiés dans le \emph{data frame} des coefficients d'altérabilité (argument
\code{alterability_df}).

\strong{La valeur par défaut} est \code{alterTotal1 = 0.0} (totaux de contrôle transversaux de 1\if{html}{\out{<sup>}}ère\if{html}{\out{</sup>}} dimension
contraignants).}

\item{alterTotal2}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut pour les totaux de contrôle transversaux
de la 2\if{html}{\out{<sup>}}ème\if{html}{\out{</sup>}} dimension. Il s'appliquera aux totaux de contrôle transversaux pour lesquels des coefficients
d'altérabilité n'ont pas déjà été spécifiés dans le \emph{data frame} des coefficients d'altérabilité (argument
\code{alterability_df}).

\strong{La valeur par défaut} est \code{alterTotal2 = 0.0} (totaux de contrôle transversaux de 2\if{html}{\out{<sup>}}ème\if{html}{\out{</sup>}} dimension
contraignants).}
}
\value{
Une liste avec les éléments du problème de ratissage (excluant les totaux temporels implicites) :
\itemize{
\item \code{x}         : vecteur des valeurs initiales des séries composantes
\item \code{c_x}       : vecteur des coefficients d'altérabilité des séries composantes
\item \code{comp_cols} : vecteur des noms des séries composantes (colonnes de \code{data_df})
\item \code{g}         : vecteur des valeurs initiales des totaux transversaux
\item \code{c_g}       : vecteur des coefficients d'altérabilité des totaux transversaux
\item \code{tot_cols}  : vecteur des noms des totaux transversaux (colonnes de \code{data_df})
\item \code{G}         : matrice d'agrégation des totaux transversaux (\code{g = G \%*\% x})
}
}
\description{
Cette fonction est utilisée à l'interne par \code{\link[=tsraking]{tsraking()}} pour construire les éléments du problème de ratissage. Elle peut
également être utile pour dériver manuellement les totaux transversaux (des marges) du problème de ratissage (en dehors du
contexte de \code{\link[=tsraking]{tsraking()}}).
}
\details{
Voir \code{\link[=tsraking]{tsraking()}} pour une description détaillée des problèmes de \emph{ratissage de séries chronologiques}.

Les éléments du problème de ratissage renvoyés n'incluent pas les totaux temporels implicites des séries de
composantes, le cas échéant (c.-à-d., les éléments \code{g} et \code{G} ne contiennent que l'information sur les totaux
transversaux).

Lorsque les données d'entrée contiennent plusieurs périodes (scénario de préservation des totaux temporels),
les éléments \code{x}, \code{c_x}, \code{g}, \code{c_g} et \code{G} du problème de ratissage sont construits \emph{colonne par colonne}
(selon le principe « column-major order » en anglais), ce qui correspond au comportement par défaut de R lors
de la conversion d'objets de la classe « matrix » en vecteurs.
}
\examples{
# Dériver les totaux de marge d'un cube de données à deux dimensions (2 x 3) 
# en utilisant les métadonnées de `tsraking()`.

mes_meta <- data.frame(series = c("A1", "A2", "A3",
                                  "B1", "B2", "B3"),
                       total1 = c(rep("totA", 3),
                                  rep("totB", 3)),
                       total2 = rep(c("tot1", "tot2", "tot3"), 2))
mes_meta

# 6 périodes de données avec totaux de marge initialisés à `NA` (ces derniers doivent
# OBLIGATOIREMENT exister dans les données d'entrée mais peuvent être `NA`).
mes_series <- data.frame(A1 = c(12, 10, 12,  9, 15,  7),
                         B1 = c(20, 21, 15, 17, 19, 18),
                         A2 = c(14,  9,  8,  9, 11, 10),
                         B2 = c(20, 29, 20, 24, 21, 17),
                         A3 = c(13, 15, 17, 14, 16, 12),
                         B3 = c(24, 20, 30, 23, 21, 19),
                         tot1 = rep(NA, 6),
                         tot2 = rep(NA, 6),
                         tot3 = rep(NA, 6),
                         totA = rep(NA, 6),
                         totB = rep(NA, 6))

# Obtenir les éléments du problème de ratissage.
p <- build_raking_problem(mes_series, mes_meta)
str(p)

# Calculer les 5 totaux de marge pour les 6 périodes.
mes_series[p$tot_cols] <- p$G \%*\% p$x
mes_series
}
\seealso{
\code{\link[=tsraking]{tsraking()}} \code{\link[=build_balancing_problem]{build_balancing_problem()}}
}
