% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stock_benchmarking.R
\name{stock_benchmarking}
\alias{stock_benchmarking}
\title{Rétablir les contraintes temporelles pour des séries de stocks}
\usage{
stock_benchmarking(
  series_df,
  benchmarks_df,
  rho,
  lambda,
  biasOption,
  bias = NA,
  low_freq_periodicity = NA,
  n_low_freq_proj = 1,
  proj_knots_rho_bd = 0.995,
  tolV = 0.001,
  tolP = NA,
  warnNegResult = TRUE,
  tolN = -0.001,
  var = "value",
  with = NULL,
  by = NULL,
  constant = 0,
  negInput_option = 0,
  allCols = FALSE,
  quiet = FALSE
)
}
\arguments{
\item{series_df}{(obligatoire)

\emph{Data frame}, ou objet compatible, qui contient les données de la (des) série(s) indicatrice(s) à étalonner. En plus de
la (des) variable(s) contenant les données, spécifiée(s) avec l'argument \code{var}, le \emph{data frame} doit aussi contenir deux
variables numériques, \code{year} et \code{period}, identifiant les périodes des séries indicatrices.}

\item{benchmarks_df}{(obligatoire)

\emph{Data frame}, ou objet compatible, qui contient les étalons. En plus de la (des) variable(s) contenant les données,
spécifiée(s) avec l'argument \code{with}, le \emph{data frame} doit aussi contenir quatre variables numériques, \code{startYear},
\code{startPeriod}, \code{endYear} et \code{endPeriod}, identifiant les périodes des séries indicatrices couvertes par chaque étalon.}

\item{rho}{(obligatoire)

Nombre réel compris dans l'intervalle \eqn{[0,1]} qui spécifie la valeur du paramètre autorégressif \eqn{\rho}.
Voir la section \strong{Détails} pour plus d'informations sur l'effet du paramètre \eqn{\rho}.}

\item{lambda}{(obligatoire)

Nombre réel, avec des valeurs suggérées dans l'intervalle \eqn{[-3,3]}, qui spécifie la valeur du paramètre du modèle
d'ajustement \eqn{\lambda}. Les valeurs typiques sont \code{lambda = 0.0} pour un modèle additif et \code{lambda = 1.0} pour un
modèle proportionnel.}

\item{biasOption}{(obligatoire)

Spécification de l'option d'estimation du biais :
\itemize{
\item \code{1} : Ne pas estimer le biais. Le biais utilisé pour corriger la série indicatrice sera la valeur
spécifiée avec l'argument \code{bias}.
\item \code{2} : Estimer le biais, afficher le résultat, mais ne pas l'utiliser. Le biais utilisé pour corriger
la série indicatrice sera la valeur spécifiée avec l'argument \code{bias}.
\item \code{3} : Estimer le biais, afficher le résultat et utiliser le biais estimé pour corriger la série indicatrice.
Toute valeur spécifiée avec l'argument \code{bias} sera ignorée.
}

L'argument \code{biasOption} n'est pas utilisé quand \code{rho = 1.0}. Voir la section \strong{Détails} pour plus d'informations sur
le biais.}

\item{bias}{(optionnel)

Nombre réel, ou \code{NA}, spécifiant la valeur du biais défini par l'utilisateur à utiliser pour la correction de la série
indicatrice avant de procéder à l'étalonnage. Le biais est ajouté à la série indicatrice avec un modèle additif
(argument \code{lambda = 0.0}) alors qu'il est multiplié dans le cas contraire (argument \code{lambda != 0.0}). Aucune correction
de biais n'est appliquée lorsque \code{bias = NA}, ce qui équivaut à spécifier \code{bias = 0.0} lorsque \code{lambda = 0.0} et
\code{bias = 1.0} dans le cas contraire. L'argument \code{bias} n'est pas utilisé lorsque \code{biasOption = 3} ou \code{rho = 1.0}. Voir la
section \strong{Détails} pour plus d'informations sur le biais.

\strong{La valeur par défaut} est \code{bias = NA} (pas de biais défini par l'utilisateur).}

\item{low_freq_periodicity}{(optionnel)

Nombre entier positif représentant le nombre de périodes définissant la \emph{basse fréquence} (e.g., celle des étalons) pour
l'ajout de nœuds supplémentaires à la spline cubique (avant le premier étalon et après le dernier étalon). Par exemple,
\ifelse{latex}{\code{low_freq _periodicity = 3}}{\code{low_freq_periodicity = 3}} avec des indicateurs mensuels
définira des nœuds trimestriels. Des nœuds annuels sont ajoutés lorsque \code{low_freq_periodicity = NA}.

\strong{La valeur par défaut} est \code{low_freq_periodicity = NA} (nœuds annuels).}

\item{n_low_freq_proj}{(optionnel)

Entier non négatif représentant le nombre de nœuds de basse fréquence (tel que défini avec l'argument
\code{low_freq_periodicity}) à ajouter aux deux extrémités (avant le premier étalon et après le dernier étalon)
avant de commencer à ajouter des nœuds de \emph{haute fréquence} (celle de la série indicatrice).

\strong{La valeur par défaut} est \code{n_low_freq_proj = 1}.}

\item{proj_knots_rho_bd}{(optionnel)

Limite qui s'applique à la valeur spécifiée avec l'argument \code{rho} et qui determine le type noœuds supplémentaires à
ajouter aux deux extrémités (avant le premier étalon et après le dernier étalon). Lorsque \code{rho > proj_knots_rho_bd}, des
nœuds de \emph{haute fréquence} (celle de la série indicatrice) sont utilisés immédiatement aux deux extrémité. Autrement,
lorsque \code{rho <= proj_knots_rho_bd}, des nœuds de \emph{basse fréquence} (voir les arguments \code{low_freq_periodicity} et
\code{n_low_freq_proj}) sont d'abord projetés de part et d'autre. Notez que pour des stocks trimestriels, le cube de
\code{proj_knots_rho_bd} est utilisé. Par conséquent, la valeur de l'argument \code{proj_knots_rho_bd} doit correspondre à des
indicateurs de stocks mensuels; elle est ajustée à l'interne pour des stocks trimestriels. Cet argument vise à atteindre
un compromis pour les périodes à l'extérieur (avant ou après) les étalons (points d'ancrage) fournis en entrée,
c'est-à-dire des ajustements de type Denton (en ligne droite) lorsque \code{rho} s'approche de 1 (lorsque
\code{rho > proj_knots_rho_bd}) et une spline cubique d'apparence normale (sans contorsions excessives) dans le cas contraire
(lorsque \code{rho <= proj_knots_rho_bd}). La section \strong{Détails} contient plus d'informations sur ce sujet et certains
cas illustratifs sont fournis dans la section \strong{Exemples}.

\strong{La valeur par défaut} est \code{proj_knots_rho_bd = 0.995} (\eqn{0.995^3} pour des indicateurs de stocks trimestriels).}

\item{tolV, tolP}{(optionnel)

Nombre réel non négatif, ou \code{NA}, spécifiant la tolérance, en valeur absolue ou en pourcentage, à utiliser pour
la validation des étalons contraignants (coefficient d'altérabilité de \eqn{0.0}) en sortie. Cette validation consiste à
comparer la valeur des étalons contraignants en entrée à la valeur équivalente calculée à partir des données de la série
étalonnée (sortie). Les arguments \code{tolV} et \code{tolP} ne peuvent pas être spécifiés tous les deux à la fois (l'un doit être
spécifié tandis que l'autre doit être \code{NA}).

\strong{Exemple :} pour une tolérance de 10 \emph{unités}, spécifiez \verb{tolV = 10, tolP = NA}; pour une tolérance de 1\%,
spécifiez \verb{tolV = NA, tolP = 0.01}.

\strong{Les valeurs par défaut} sont \code{tolV = 0.001} et \code{tolP = NA}.}

\item{warnNegResult}{(optionnel)

Argument logique (\emph{logical}) spécifiant si un message d'avertissement doit être affiché lorsqu'une valeur négative
créée par la fonction dans la série étalonnée (en sortie) est inférieure au seuil spécifié avec l'argument \code{tolN}.

\strong{La valeur par défaut} est \code{warnNegResult = TRUE}.}

\item{tolN}{(optionnel)

Nombre réel négatif spécifiant le seuil pour l'identification des valeurs négatives. Une valeur est considérée
négative lorsqu'elle est inférieure à ce seuil.

\strong{La valeur par défaut} est \code{tolN = -0.001}.}

\item{var}{(optionnel)

Vecteur (longueur minimale de 1) de chaînes de caractères spécifiant le(s) nom(s) de variable(s) du \emph{data frame} des séries
indicatrices (argument \code{series_df}) contenant les valeurs et (optionnellement) les coefficients d'altérabilité définis par
l'utilisateur de la (des) série(s) à étalonner. Ces variables doivent être numériques.

La syntaxe est \code{var = c("serie1 </ alt_ser1>", "serie2 </ alt_ser2>", ...)}. Des coefficients d'altérabilité par défaut
de \eqn{1.0} sont utilisés lorsqu'une variable de coefficients d'altérabilité définie par l'utilisateur n'est pas spécifiée
à côté d'une variable de série indicatrice. Voir la section \strong{Détails} pour plus d'informations sur les coefficients
d'altérabilité.

\strong{Exemple :} \code{var = "value / alter"} étalonnerait la variable \code{value} du \emph{data frame} des séries indicatrices avec les
coefficients d'altérabilité contenus dans la variable \code{alter} tandis que \code{var = c("value / alter", "value2")} étalonnerait
en plus la variable \code{value2} avec des coefficients d'altérabilité par défaut de \eqn{1.0}.

\strong{La valeur par défaut} est \code{var = "value"} (étalonner la variable \code{value} avec des coefficients d'altérabilité par défaut
de \eqn{1.0}).}

\item{with}{(optionnel)

Vecteur (même longueur que l'argument \code{var}) de chaînes de caractères, ou \code{NULL}, spécifiant le(s) nom(s) de variable(s)
du \emph{data frame} des étalons (argument \code{benchmarks_df}) contenant les valeurs et (optionnellement) les coefficients
d'altérabilité définis par l'utilisateur des étalons. Ces variables doivent être numériques. La spécification de \code{with = NULL}
entraîne l'utilisation de variable(s) d'étalons correspondant à la (aux) variable(s) spécifiée(s) avec l'argument \code{var} sans
coefficients d'altérabilité d'étalons définis par l'utilisateur (c'est  à dire des coefficients d'altérabilité par défaut de
\eqn{0.0} correspondant à des étalons contraignants).

La syntaxe est \code{with = NULL} ou \code{with = c("bmk1 </ alt_bmk1>", "bmk2 </ alt_bmk2>", ...)}. Des coefficients d'altérabilité
par défaut de \eqn{0.0} (étalons contraignants) sont utilisés lorsqu'une variable de coefficients d'altérabilité définie
par l'utilisateur n'est pas spécifiée à côté d'une variable d'étalon. Voir la section \strong{Détails} pour plus d'informations
sur les coefficients d'altérabilité.

\strong{Exemple :} \code{with = "val_bmk"} utiliserait la variable \code{val_bmk} du \emph{data frame} des étalons avec les coefficients
d'altérabilité par défaut de \eqn{0.0} pour étalonner la série indicatrice tandis que
\code{with = c("val_bmk", "val_bmk2 / alt_bmk2")} étalonnerait en plus une deuxième série indicatrice en utilisant la variable
d'étalons \code{val_bmk2} avec les coefficients d'altérabilité d'étalons contenus dans la variable \code{alt_bmk2}.

\strong{La valeur par défaut} est \code{with = NULL} (même(s) variable(s) d'étalons que l'argument \code{var} avec des coefficients
d'altérabilité d'étalons par défaut de \eqn{0.0}).}

\item{by}{(optionnel)

Vecteur (longueur minimale de 1) de chaînes de caractères, ou \code{NULL}, spécifiant le(s) nom(s) de variable(s) dans les
\emph{data frames} d'entrée (arguments \code{series_df} et \code{benchmarks_df}) à utiliser pour former des groupes (pour le traitement
« groupes-BY ») et permettre l'étalonnage de plusieurs séries en un seul appel de fonction. Les variables groupes-BY
peuvent être numériques ou caractères (facteurs ou non), doivent être présentes dans les deux \emph{data frames} d'entrée
et apparaîtront dans les trois \emph{data frames} de sortie (voir la section \strong{Valeur de retour}). Le traitement groupes-BY
n'est pas implémenté lorsque \code{by = NULL}. Voir « Étalonnage de plusieurs séries » dans la section \strong{Détails} pour plus
d'informations.

\strong{La valeur par défaut} est \code{by = NULL} (pas de traitement groupes-BY).}

\item{constant}{(optionnel)

Nombre réel qui spécifie une valeur à ajouter temporairement à la fois à la (aux) série(s) indicatrice(s) et aux étalons
avant de résoudre les problèmes d'étalonnage proportionnels (\code{lambda != 0.0}). La constante temporaire est enlevée de la
série étalonnée finale en sortie. Par exemple, la spécification d'une (petite) constante permettrait l'étalonnage
proportionnel avec \code{rho = 1} (étalonnage de  Denton proportionnel) sur avec des séries indicatrices qui comprennent des
valeurs de 0. Sinon, l'étalonnage proportionnel avec des valeurs de 0 pour la série indicatrice n'est possible que
lorsque \code{rho < 1}. Spécifier une constante avec l'étalonnage additif (\code{lambda = 0.0}) n'a pas d'impact sur les données
étalonnées résultantes. Les variables de données dans le \emph{data frame} de sortie \strong{graphTable} incluent la constante,
correspondant au problème d'étalonnage effectivement résolu par la fonction.

\strong{La valeur par défaut} est \code{constant = 0} (pas de constante additive temporaire).}

\item{negInput_option}{(optionnel)

Traitement des valeurs négatives dans les données d'entrée pour l'étalonnage proportionnel (\code{lambda != 0.0}) :
\itemize{
\item \code{0} : Ne pas autoriser les valeurs négatives pour l'étalonnage proportionnel. Un message d'erreur est affiché en
présence de valeurs négatives dans les séries indicatrices ou les étalons d'entrée et des valeurs manquantes (\code{NA})
sont renvoyées pour les séries étalonnées. Ceci correspond au comportement de G-Séries 2.0.
\item \code{1} : Autoriser les valeurs négatives pour l'étalonnage proportionnel mais avec l'affichage d'un message d'avertissement.
\item \code{2} : Autoriser les valeurs négatives pour l'étalonnage proportionnel sans afficher de message.
}

\strong{La valeur par défaut} est \code{negInput_option = 0} (ne pas autoriser les valeurs négatives pour l'étalonnage proportionnel).}

\item{allCols}{(optionnel)

Argument logique (\emph{logical}) spécifiant si toutes les variables du \emph{data frame} des séries indicatrices (argument \code{series_df}),
autres que \code{year} et \code{period}, déterminent l'ensemble des séries à étalonner. Les valeurs spécifiées avec les arguments \code{var}
et \code{with} sont ignorées lorsque \code{allCols = TRUE}, ce qui implique automatiquement des coefficients d'altérabilité par défaut,
et des variables avec les mêmes noms que les séries indicatrices doivent exister dans le \emph{data frame} des étalons (argument
\code{benchmarks_df}).

\strong{La valeur par défaut} est \code{allCols = FALSE}.}

\item{quiet}{(optionnel)

Argument logique (\emph{logical}) spécifiant s'il faut ou non afficher uniquement les informations essentielles telles que les
messages d'avertissements, les messages d'erreurs et les informations sur les variables (séries) ou les groupes-BY lorsque
plusieurs séries sont étalonnées en un seul appel à la fonction. Nous vous déconseillons d'\emph{envelopper} votre appel à
\code{\link[=benchmarking]{benchmarking()}} avec \code{\link[=suppressMessages]{suppressMessages()}} afin de supprimer l'affichage des informations sur les variables (séries) ou les
groupes-BY lors du traitement de plusieurs séries, car cela compliquerait le dépannage en cas de problèmes avec des séries
individuelles. Notez que la spécification de \code{quiet = TRUE} annulera également l'argument \code{verbose}.

\strong{La valeur par défaut} est \code{quiet = FALSE}.}
}
\value{
La fonction renvoie une liste de quatre \emph{data frames} :
\itemize{
\item \strong{series} : \emph{data frame} contenant les données étalonnées (sortie principale de la fonction). Les variables BY spécifiées
avec l'argument \code{by} sont incluses dans le \emph{data frame} mais pas les variables de coefficient d'altérabilité spécifiées
avec l'argument \code{var}.
\item \strong{benchmarks} : copie du \emph{data frame} d'entrée des étalons (à l'exclusion des étalons non valides, le cas échéant).
Les variables BY spécifiées avec l'argument \code{by} sont incluses dans le \emph{data frame} mais pas les variables de coefficient
d'altérabilité spécifiées avec l'argument \code{with}.
\item \strong{graphTable} : \emph{data frame} contenant des données supplémentaires utiles pour produire des tableaux et des graphiques
analytiques (voir la fonction \code{\link[=plot_graphTable]{plot_graphTable()}}). Il contient les variables suivantes en plus des variables BY spécifiées
avec l'argument \code{by} :
\itemize{
\item \code{varSeries} : Nom de la variable de la série indicatrice
\item \code{varBenchmarks} : Nom de la variable des étalons
\item \code{altSeries} : Nom de la variable des coefficients d'altérabilité définis par l'utilisateur pour la série indicatrice
\item \code{altSeriesValue} : Coefficients d'altérabilité de la série indicatrice
\item \code{altbenchmarks} : Nom de la variable des coefficients d'altérabilité définis par l'utilisateur pour les étalons
\item \code{altBenchmarksValue} : Coefficients d'altérabilité des étalons
\item \code{t} : Identificateur de la période de la série indicatrice (1 à \eqn{T})
\item \code{m} : Identificateur des périodes de couverture de l'étalon (1 à \eqn{M})
\item \code{year} : Année civile du point de données
\item \code{period} : Valeur de la période (du cycle) du point de données (1 à \code{periodicity})
\item \code{rho} : Paramètre autorégressif \eqn{\rho} (argument \code{rho})
\item \code{lambda} : Paramètre du modèle d'ajustement \eqn{\lambda} (argument \code{lambda})
\item \code{bias} : Ajustement du biais (par défaut, défini par l'utilisateur ou biais estimé selon les arguments \code{biasOption}
et \code{bias})
\item \code{periodicity} : Le nombre maximum de périodes dans une année (par exemple 4 pour une série indicatrice trimestrielle)
\item \code{date} : Chaîne de caractères combinant les valeurs des variables \code{year} et \code{period}
\item \code{subAnnual} : Valeurs de la série indicatrice
\item \code{benchmarked} : Valeurs de la série étalonnée
\item \code{avgBenchmark} : Valeurs des étalons divisées par le nombre de périodes de couverture
\item \code{avgSubAnnual} : Valeurs moyennes de la série indicatrice (variable \code{subAnnual}) pour les périodes couvertes par les
étalons
\item \code{subAnnualCorrected} : Valeurs de la série indicatrice corrigée pour le biais
\item \code{benchmarkedSubAnnualRatio} : Différence (\eqn{\lambda = 0}) ou ratio (\eqn{\lambda \ne 0}{lambda != 0}) des valeurs
des variables \code{benchmarked} et \code{subAnnual}
\item \code{avgBenchmarkSubAnnualRatio} : Différence (\eqn{\lambda = 0}) ou ratio (\eqn{\lambda \ne 0}{lambda != 0}) des valeurs
des variables \code{avgBenchmark} et \code{avgSubAnnual}
\item \code{growthRateSubAnnual} : Différence (\eqn{\lambda = 0}) ou différence relative (\eqn{\lambda \ne 0}{lambda != 0}) d'une
période à l'autre des valeurs de la série indicatrice (variable \code{subAnnual})
\item \code{growthRateBenchmarked} : Différence (\eqn{\lambda = 0}) ou différence relative (\eqn{\lambda \ne 0}{lambda != 0}) d'une
période à l'autre des valeurs de la série étalonnée (variable \code{benchmarked})
}
\item \strong{splineKnots} : ensemble de coordonnées \code{x} et \code{y} (nœuds) utilisées pour estimer la spline cubique naturelle avec la
fonction \code{stats::spline()}. En plus de l'ensemble original de nœuds correspondant aux étalons (points d'ancrage) contraignants,
des nœuds supplémentaires sont également ajoutés au début et à la fin afin de traiter le \emph{problème d'actualité} de
l'étalonnage et d'approximer une spline de \emph{pente=0} aux deux extrémités (voir section \strong{Détails}). Il contient les variables
suivantes en plus des variables BY spécifiées avec l'argument \code{by} :
\itemize{
\item \code{varSeries} : Nom de la variable de la série indicatrice
\item \code{varBenchmarks} : Nom de la variable des étalons
\item \code{x} : Coordonnée \code{x} de la spline cubique
\item \code{y} : Coordonnée \code{y} de la spline cubique
\item \code{extraKnot} : Valeur logique (\emph{logical}) identifiant les nœuds supplémentaires ajoutés au début et à la fin.
}

Les enregistrements pour lesquels \code{extraKnot == FALSE} correspondent aux enregistrements du \emph{data frame} de sortie
\strong{graphTable} pour lesquels \code{m} n'est pas manquant (pas \code{NA}), avec \code{x = t} et \code{y = benchmarkedSubAnnualRatio}.
}

Notes :
\itemize{
\item Le \emph{data frame} de sortie \strong{benchmarks} contient toujours les étalons originaux fournis dans le \emph{data frame} d'entrée
des étalons. Les étalons modifiés non contraignants, le cas échéant, peuvent être récupérés (calculés) à partir du \emph{data frame}
de sortie \strong{series}.
\item La fonction renvoie un objet \code{NULL} si une erreur se produit avant que le traitement des données ne puisse commencer.
Dans le cas contraire, si l'exécution est suffisamment avancée pour que le traitement des données puisse commencer, alors
un objet incomplet sera renvoyé en cas d'erreur (par exemple, un \emph{data frame} de sortie \strong{series} avec des valeurs \code{NA}
pour les données étalonnées).
\item La fonction renvoie des objets « data.frame » qui peuvent être explicitement convertis en d'autres types d'objets avec la
fonction \verb{as*()} appropriée (ex., \code{tibble::as_tibble()} convertirait n'importe lequel d'entre eux en tibble).
}
}
\description{
Fonction spécifiquement destinée à l'étalonnage des séries de stocks où les étalons sont des points d'ancrage couvrant
une seule période de la série indicatrice. Les étalons couvrant plus d'une période de la série indicatrice ne peuvent pas
être utilisés avec cette fonction. La fonction \code{\link[=benchmarking]{benchmarking()}} doit être utilisée à la place pour étalonner des séries de
flux (« non-stock »).

Plusieurs séries de stocks peuvent être étalonnées en un seul appel de fonction.

Notez que les fonctions \code{\link[=stock_benchmarking]{stock_benchmarking()}} et \code{\link[=benchmarking]{benchmarking()}} partagent principalement les mêmes arguments et renvoient
le même type d'objet. Les différences sont énumérées ci-dessous :
\itemize{
\item L'argument \code{verbose} n'est pas défini pour \code{\link[=stock_benchmarking]{stock_benchmarking()}}.
\item Des arguments supplémentaires sont définis pour \code{\link[=stock_benchmarking]{stock_benchmarking()}} :
\itemize{
\item \code{low_freq_periodicity}
\item \code{n_low_freq_proj}
\item \code{proj_knots_rho_bd}
}
\item La liste renvoyée par \code{\link[=stock_benchmarking]{stock_benchmarking()}} contient un \emph{data frame} supplémentaire :
\itemize{
\item \code{splineKnots}
}
}

Voir la section \strong{Détails} pour plus d'informations sur les similitudes et les différences entre les fonctions
\code{\link[=stock_benchmarking]{stock_benchmarking()}} et \code{\link[=benchmarking]{benchmarking()}}.

\emph{Un équivalent direct de \code{\link[=stock_benchmarking]{stock_benchmarking()}} n'existe pas dans G-Séries 2.0 en SAS\eqn{^\circledR}{®}.}
}
\details{
\subsection{Comparaison avec \code{\link[=benchmarking]{benchmarking()}}}{

Avec des séries de stocks, \code{\link[=benchmarking]{benchmarking()}} est connu pour produire des bris dans les ajustements d'étalonnage aux périodes
correspondant aux étalons (points d'ancrage). \code{\link[=stock_benchmarking]{stock_benchmarking()}} résout ce problème en travaillant directement sur les
ajustements d'étalonnage. Des ajustements lisses pour les stocks sont garantis en estimant une spline cubique de \emph{pente=0}
(une spline qui est \emph{plate} aux deux extrémités) passant par les nœuds correspondant à la différence (lorsque l'argument
\code{lambda = 0.0}) ou au ratio (sinon) entre les étalons (points d'ancrage) et les valeurs correspondantes de la série indicatrice.
Ces nœuds sont parfois appelés \emph{différences BI} ou \emph{ratios BI} (\emph{\strong{B}enchmark-to-\strong{I}ndicator} en anglais). Les
interpolations à partir de la spline cubique estimée fournissent alors les ajustements d'étalonnage pour les périodes entre
les étalons.

Les arguments \code{rho}, \code{lambda}, \code{biasOption} et \code{bias} jouent un rôle similaire à ceux de \code{\link[=benchmarking]{benchmarking()}}. Cependant, notez que
pour \code{\link[=stock_benchmarking]{stock_benchmarking()}}, l'argument \code{rho} n'affecte les résultats que pour les périodes à l'extérieur, ou autour, du premier
et du dernier étalon et \code{lambda} ne prend que deux valeurs en pratique : \code{lambda = 0.0} pour des ajustements additifs
(interpolations par spline cubique où les nœuds sont des \emph{différences BI}) ou \code{lambda = 1.0} pour des ajustements multiplicatifs
(interpolations par spline cubique où les nœuds sont des \emph{ratios BI}). Toute valeur non nulle pour \code{lambda} donnerait le même
résultat que \code{lambda = 1.0}. Les coefficients d'altérabilité jouent également un rôle similaire à ceux de \code{\link[=benchmarking]{benchmarking()}} et ont
les mêmes valeurs par défaut, c'est-à-dire \eqn{1.0} pour la série indicatrice (valeurs non contraignantes) et \eqn{0.0} pour
les étalons (étalons contraignants). Cependant, comme pour l'argument \code{lambda}, les coefficients d'altérabilité de cette
fonction ne prennent que deux valeurs en pratique : \eqn{0.0} pour des valeurs contraignantes ou \eqn{1.0} pour des valeurs
non contraignantes. Tout coefficient d'altérabilité non nul renverrait le même résultat qu'un coefficient de \eqn{1.0}. Une
autre différence avec \code{\link[=benchmarking]{benchmarking()}} est que les coefficients d'altérabilité définis par l'utilisateur sont autorisés même
si \code{rho = 1} avec \code{\link[=stock_benchmarking]{stock_benchmarking()}}. Enfin, le fait de spécifier un étalon non contraignant avec \code{\link[=stock_benchmarking]{stock_benchmarking()}}
équivaut à l'ignorer complètement, comme si l'étalon en question n'était pas inclus dans le fichier d'entrée des étalons. Par
rapport à \code{\link[=benchmarking]{benchmarking()}}, cette approche se traduit généralement par un impact plus important des étalons non contraignants
sur les résultats de l'étalonnage (sur les stocks étalonnés résultants).
}

\subsection{Solution autour des premier et dernier étalons (\emph{problème d'actualité} de l'étalonnage)}{

Une spline de \emph{pente=0} est choisie parce qu'elle correspond conceptuellement à l'approche (populaire) d'\emph{étalonnage de
Denton} (\code{rho = 1}). Afin de fournir une solution avant le premier étalon et après le dernier étalon qui soit semblable à
celle de \code{\link[=benchmarking]{benchmarking()}} lorsque \code{rho < 1}, c'est-à-dire des ajustements convergeant vers le biais à une vitesse dictée par
l'argument \code{rho}, des nœuds supplémentaires sont ajoutés aux deux extrémités avant d'estimer la spline. Par défaut, un nœud
supplémentaire de basse fréquence (défini par l'argument \code{low_freq_periodicity}) est ajouté de chaque côté (au début et à la fin),
c'est-à-dire qu'un nœud supplémentaire est ajouté avant le premier étalon et après le dernier étalon. Ensuite, des nœuds de
haute fréquence (celle de la série indicatrice) sont ajoutés pour couvrir l'étendue de la série indicatrice, à laquelle est
ajoutée une année supplémentaire de nœuds de haute fréquence. La valeur de tous ces nœuds supplémentaires est basée sur les
arguments \code{rho}, \code{biasOption} et \code{bias}. Cela produit des ajustements lisses et naturels pour les périodes à l'extérieur, ou
autour, des premier et dernier étalons qui convergent progressivement vers le biais, de manière similaire à \code{\link[=benchmarking]{benchmarking()}}.
Le nombre de nœuds supplémentaires de basse fréquence à ajouter peut être modifié avec l'argument \code{n_low_freq_proj}.
L'utilisation immédiate de nœuds de haute fréquence (\code{n_low_freq_proj = 0}) produirait les mêmes ajustements projetés que
\code{\link[=benchmarking]{benchmarking()}}. Cependant, notez que cela tend à produire une spline d'apparence peu naturelle (exagérément contortionnée)
autour des premier et dernier étalons qui pourrait être révisée de manière substantielle une fois que le prochain étalon sera
disponible. L'utilisation de la valeur par défaut \code{n_low_freq_proj = 1} fonctionne généralement mieux. Cependant, lorsque
\code{rho} est \emph{proche de 1} (voir l'argument \code{proj_knots_rho_bd}), des noeuds de haute fréquence sont immédiatement ajoutés de
chaque côté afin d'assurer des ajustements projetés de type Denton (en ligne droite) pour les périodes à l'extérieur des
premier et dernier étalons. Enfin, une spline cubique de \emph{pente=0} passant à travers les nœuds (originaux et supplémentaires)
est estimée. Notez qu'en pratique, la spline de \emph{pente=0} est en fait approximée en reproduisant la valeur des nœuds aux
extrémités 100 fois au cours de la période suivante (à une fréquence correspondant à 100 fois la fréquence de la série
indicatrice).

Une \emph{spline naturelle} aux nœuds d'extrémité originaux (premier et dernier étalons) peut être approximée en spécifiant
une grande valeur pour l'argument \code{low_freq_periodicity}. Plus la valeur de \code{low_freq_periodicity} est grande, plus la spline
cubique se comportera comme une \emph{spline naturelle} (dérivée seconde égale à 0 aux extrémités, c'est-à-dire une spline qui
garde une pente constante aux extrémités au lieu d'être plate comme une spline de \emph{pente=0}).

En résumé, les ajustements projetés sont contrôlés avec les arguments \code{rho}, \code{bias} (et \code{biasOption}), \code{n_low_freq_proj},
\code{proj_knots_rho_bd} et \code{low_freq_periodicity} :
\itemize{
\item Les valeurs par défaut de ces arguments produisent des ajustements projetés du type fonction \code{benchmarking} (convergence
raisonnablement lente vers le biais).
\item Des valeurs plus petites de \code{rho} généreraient une convergence plus rapide vers le biais.
\item Spécifier un biais défini par l'utilisateur avec l'argument \code{bias} lorsque \code{rho < 1} est une autre façon d'influencer la
forme des ajustements projetés.
\item Spécifier \code{rho = 1} produit des ajustements projetés de type Denton (premiers/derniers ajustements répétés sans convergence
vers le biais).
\item Spécifier une grande valeur pour \code{low_freq_periodicity} génère des ajustements projetés qui se comportent plus comme une
spline naturelle, c'est-à-dire des ajustements qui continuent dans la même direction au premier/dernier étalon. Plus la valeur
de \code{low_freq_periodicity} est grande, plus les ajustements projetés continuent à aller dans la même direction avant de \emph{tourner}.
}

La spline cubique associée aux ajustements de \code{\link[=stock_benchmarking]{stock_benchmarking()}} peut être commodément tracée avec \code{\link[=plot_benchAdj]{plot_benchAdj()}}.
}

\subsection{Note sur les révisions des ajustements d'étalonnage}{

Les ajustements de \code{\link[=benchmarking]{benchmarking()}} ne seraient pas révisés si tous les futurs étalons tombaient exactement sur ceux qui sont
projetés (sur la base du biais et de la valeur de \code{rho}) et si le biais était fixé. La même chose pourrait être obtenue avec
\code{\link[=stock_benchmarking]{stock_benchmarking()}} si \emph{suffisamment} de nœuds de basse fréquence (celle des étalons) étaient projetés. Le problème avec
cette approche, cependant, est que les ajustements projetés peuvent ne pas sembler naturels car la spline peut osciller plus
que souhaité autour des nœuds projetés. Ceci est clairement perceptible lorsque \code{rho} s'approche de 1 et que la spline oscille
autour des nœuds projetés alignés horizontalement au lieu d'être alignée sur une ligne parfaitement droite. L'implémentation
par défaut de la spline autour des premier et dernier étalons décrite précédemment vise à atteindre une \emph{solution de meilleur
compromis} :
\itemize{
\item une spline d'apparence naturelle aux extrémités évitant les oscillations et les contorsions excessives;
\item de petites révisions de la spline si l'étalon suivant est proche de celui projeté lorsque \code{rho} est \emph{assez éloigné}
de 1 (\code{rho <= proj_knots_rho_bd});
\item ajustements projetés qui sont en ligne droite (sans oscillations) lorsque \code{rho} s'approche de 1 (\code{rho > proj_knots_rho_bd}).
}

Les sous-sections \emph{Étalonnage de plusieurs séries}, \emph{Arguments \code{constant} et \code{negInput_option}} et \emph{Traitement des valeurs
manquantes (\code{NA})} à la fin de la section \strong{Détails} de \code{\link[=benchmarking]{benchmarking()}} sont également pertinentes pour
\code{\link[=stock_benchmarking]{stock_benchmarking()}}. Consultez-les au besoin.

Enfin, notez que la spline cubique associée aux ajustements de \code{\link[=stock_benchmarking]{stock_benchmarking()}} peut être commodément tracée avec
\code{\link[=plot_benchAdj]{plot_benchAdj()}}. Cette dernière est utilisée dans les \strong{Exemples} pour illustrer certains des sujets abordés ci-dessus.
}
}
\examples{
# Série de stocks trimestriels (même patron répété chaque année)
mes_ind <- ts_to_tsDF(ts(rep(c(85, 95, 125, 95), 7),
                         start = c(2013, 1),
                         frequency = 4))
head(mes_ind)

# Étalons annuels (stocks de fin d'année)
mes_eta <- ts_to_bmkDF(ts(c(135, 125, 155, 145, 165),
                          start = 2013,
                          frequency = 1),
                       discrete_flag = TRUE,
                       alignment = "e",
                       ind_frequency = 4)
mes_eta

# Étalonnage avec...
#   - valeur de `rho` recommandée pour des séries trimestrielles (`rho = 0.729`)
#   - modèle proportionnel (`lambda = 1`)
#   - correction de la série indicatrice pour le biais avec estimation du biais 
#     (`biasOption = 3`)

# ... avec `benchmarking()` (approche « Proc Benchmarking »)
res_PB <- benchmarking(mes_ind,
                       mes_eta,
                       rho = 0.729,
                       lambda = 1,
                       biasOption = 3)

# ... avec `stock_benchmarking()` (approche « Stock Benchmarking »)
res_SB <- stock_benchmarking(mes_ind,
                             mes_eta,
                             rho = 0.729,
                             lambda = 1,
                             biasOption = 3)

# Comparer les ajustements d'étalonnage des deux approches
plot_benchAdj(PB_graphTable = res_PB$graphTable,
              SB_graphTable = res_SB$graphTable)

# Avez-vous remarqué que les ajustements de `stock_benchmarking()` sont plus lisses 
# que ceux de `benchmarking()` ?

# L'amélioration de la qualité des données étalonnées qui en résulte n'est pas 
# nécessairement évidente dans cet exemple.
plot(res_SB$graphTable$t, res_SB$graphTable$benchmarked,
     type = "b", col = "red", xlab = "t", ylab = "Stocks étalonnés")
lines(res_PB$graphTable$t, res_PB$graphTable$benchmarked,
      type = "b", col = "blue")
legend(x = "topleft", bty = "n", inset = 0.05, lty = 1, pch = 1,
       col = c("red", "blue"), legend = c("res_SB", "res_PB"))
title("Stocks étalonnés")

# Qu'en est-il des cas où un indicateur plat (rectiligne) est utilisé, ce qui se produit 
# souvent en pratique en l'absence d'un bon indicateur des mouvements infra-annuels ?
mes_inds2 <- mes_ind
mes_inds2$value <- 1  # indicateur plat
res_PB2 <- benchmarking(mes_inds2,
                        mes_eta,
                        rho = 0.729,
                        lambda = 1,
                        biasOption = 3,
                        quiet = TRUE)  # ne pas afficher l'en-tête

res_SB2 <- stock_benchmarking(mes_inds2,
                              mes_eta,
                              rho = 0.729,
                              lambda = 1,
                              biasOption = 3,
                              quiet = TRUE)  # ne pas afficher l'en-tête

plot(res_SB2$graphTable$t, res_SB2$graphTable$benchmarked,
     type = "b", col = "red", xlab = "t", ylab = "Stocks étalonnés")
lines(res_PB2$graphTable$t, res_PB2$graphTable$benchmarked,
      type = "b", col = "blue")
legend(x = "topleft", bty = "n", inset = 0.05, lty = 1, pch = 1,
       col = c("red", "blue"), legend = c("res_SB2", "res_PB2"))
title("Stocks étalonnés - Indicateur plat")

# L'apparence plutôt étrange des valeurs étalonnées produites par `benchmarking()` devient 
# soudainement plus évidente. En effet, la série étalonnée correspond aux ajustements 
# d'étalonnage lorsqu'on utilise un indicateur plat (par exemple, une série de 1 avec 
# un étalonnage proportionnel) :
plot_benchAdj(PB_graphTable = res_PB2$graphTable,
              SB_graphTable = res_SB2$graphTable)

# Les lacunes de l'approche « Proc Benchmarking » (fonction `benchmarking()`) avec 
# des stocks sont également très visibles lorsque l'on regarde les taux de croissance 
# trimestriels résultants, qui sont commodément produits par `plot_graphTable()`. 
# Portez une attention particulière à la transition des taux de croissance de T4 à T1 
# à chaque année dans les graphiques PDF générés.
plot_graphTable(res_PB2$graphTable, file.path(tempdir(), "Stock_ind_plat_PB.pdf"))
plot_graphTable(res_SB2$graphTable, file.path(tempdir(), "Stock_ind_plat_SB.pdf"))


# Illustrer l'approximation d'une spline cubique naturelle aux nœuds d'extrémité originaux 
# (premier et dernier étalons) en spécifiant une grande valeur pour `low_freq_periodicity`.
res_SB3 <- stock_benchmarking(mes_ind,
                              mes_eta,
                              rho = 0.729,
                              lambda = 1,
                              biasOption = 3,
                              
                              # Grande valeur pour approximer une spline cubique naturelle
                              low_freq_periodicity = 100,
                              
                              quiet = TRUE)

plot_benchAdj(SB_graphTable = res_SB3$graphTable,
              SB_splineKnots = res_SB3$splineKnots,
              legendPos = "topleft")


# Illustrer les « oscillations » pour les ajustements projetés au-delà des nœuds 
# d'extrémité originaux avec l'étalonnage de type Denton (`rho ~ 1`) causées par 
# l'utilisation de nœuds supplémentaires de basse fréquence (annuelle).
res_SB4 <- stock_benchmarking(mes_ind,
                              mes_eta,
                              rho = 0.999,
                              lambda = 1,
                              biasOption = 3,
                              
                              # Utiliser d'abord 3 noœuds supplémentaires annuels
                              n_low_freq_proj = 3,
                              proj_knots_rho_bd = 1,
                              
                              quiet = TRUE)

plot_benchAdj(SB_graphTable = res_SB4$graphTable,
              SB_splineKnots = res_SB4$splineKnots)

# Pas d'« oscillations » avec la valeur par défaut de `proj_knots_rho_bd` parce que 
# des nœuds supplémentaires de haute fréquence (trimestrielle) sont utilisés immédiatement 
# (`n_low_freq_proj` est ignoré) puisque `rho = 0.999` excède la valeur par défaut de 
# `proj_knots_rho_bd` (0.995^3 pour des données trimestrielles). Ces ajustements projetés 
# correspondent davantage à des ajustements de type Denton (en ligne droite).
res_SB4b <- stock_benchmarking(mes_ind,
                               mes_eta,
                               rho = 0.999,
                               lambda = 1,
                               biasOption = 3,
                               quiet = TRUE)

plot_benchAdj(SB_graphTable = res_SB4b$graphTable,
              SB_splineKnots = res_SB4b$splineKnots)


# Illustrer les « contorsions » de la spline cubique autour des nœuds d'extrémité originaux 
# causées par l'utilisation immédiate de nœuds supplémentaires de haute fréquence 
# (`n_low_freq_proj = 0`), c.à-d., en utilisant les mêmes ajustements projetés que ceux qui 
# seraient obtenus avec `benchmarking()`.
#
# Pour exacerber le phénomène, nous utiliserons des données mensuelles (11 périodes entre 
# chaque étalon annuel contre seulement 3 pour des données trimestrielles, c.-à-d., une 
# spline moins contrainte) et une valeur plutôt faible de `rho` (0.5 < 0.9 = valeur 
# recommandée pour des données mensuelles) pour une convergence plus rapide vers le biais 
# des ajustements projetés.
vec_ans <- unique(mes_ind$year)
mes_ind3 <- data.frame(year = rep(vec_ans, each = 12),
                       period = rep(1:12, length(vec_ans)),
                       value = rep(1, 12 * length(vec_ans)))  # indicateur plat
mes_eta2 <- mes_eta
mes_eta2[c("startPeriod", "endPeriod")] <- 12

res_SB5 <- stock_benchmarking(mes_ind3,
                              mes_eta2,
                              rho = 0.5,
                              lambda = 1,
                              biasOption = 3,
                              
                              # Utilisation immédiate de noœuds supplémentaires mensuels
                              n_low_freq_proj = 0,
                              
                              quiet = TRUE)

plot_benchAdj(SB_graphTable = res_SB5$graphTable,
              SB_splineKnots = res_SB5$splineKnots)

# Pas de « contorsions » excessives autour des nœuds d'extrémité originaux avec la valeur 
# par défaut `n_low_freq_proj = 1`, c.-à-d., utiliser d'abord 1 nœud supplémentaire de 
# basse fréquence (annuelle).
res_SB5b <- stock_benchmarking(mes_ind3,
                               mes_eta2,
                               rho = 0.5,
                               lambda = 1,
                               biasOption = 3,
                               quiet = TRUE)

plot_benchAdj(SB_graphTable = res_SB5b$graphTable,
              SB_splineKnots = res_SB5b$splineKnots)

# Afin de mettre encore mieux en évidence les « contorsions » excessives potentielles de 
# la spline cubique lorsqu'on impose les ajustements projetés de `benchmarking()` (c.-à-d., 
# des nœuds supplémentaires de basse fréquence immédiats avec `n_low_freq_proj = 0`), 
# traçons les deux précédents ensembles d'ajustements sur le même graphique (la ligne 
# bleue correspond ici au cas `n_low_freq_proj = 0`, soit les ajustements projetés de 
# `benchmarking()` alors que la ligne rouge correspond aux ajustements par défaut de 
# `stock_benchmarking()`, soit `n_low_freq_proj = 1`).
plot_benchAdj(PB_graphTable = res_SB5$graphTable,
              SB_graphTable = res_SB5b$graphTable,
              legend = NULL)
}
\references{
Statistique Canada (2012). « Chapitre 5 : Étalonnage de stocks ». \strong{Théorie et application de l’étalonnage
(Code du cours 0436)}. Statistique Canada, Ottawa, Canada.
}
\seealso{
\code{\link[=benchmarking]{benchmarking()}} \code{\link[=plot_graphTable]{plot_graphTable()}} \link{bench_graphs} \code{\link[=plot_benchAdj]{plot_benchAdj()}}
}
