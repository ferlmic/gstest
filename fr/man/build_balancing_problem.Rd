% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsbalancing.R
\name{build_balancing_problem}
\alias{build_balancing_problem}
\title{Construire les éléments de base des problèmes d'équilibrage.}
\usage{
build_balancing_problem(
  in_ts,
  problem_specs_df,
  in_ts_name = deparse1(substitute(in_ts)),
  ts_freq = stats::frequency(in_ts),
  periods = gs.time2str(in_ts),
  n_per = nrow(as.matrix(in_ts)),
  specs_df_name = deparse1(substitute(problem_specs_df)),
  temporal_grp_periodicity = 1,
  alter_pos = 1,
  alter_neg = 1,
  alter_mix = 1,
  lower_bound = -Inf,
  upper_bound = Inf,
  validation_only = FALSE
)
}
\arguments{
\item{in_ts}{(obligatoire)

Objet de type série chronologique (« ts » ou « mts »), ou objet compatible, qui contient les données des séries
chronologiques à réconcilier. Il s'agit des données d'entrée (solutions initiales) des problèmes d'équilibrage
(« \emph{balancing} »).}

\item{problem_specs_df}{(obligatoire)

\emph{Data frame} des spécifications du problème d'équilibrage. En utilisant un format clairsemé (épars) inspiré de la
procédure LP de SAS/OR\eqn{^\circledR}{®} (SAS Institute 2015), il ne contient que les informations pertinentes
telles que les coefficients non nuls des contraintes d'équilibrage ainsi que les coefficients d'altérabilité et les
bornes inférieures/supérieures à utiliser au lieu des valeurs par défaut (c.-à-d., les valeurs qui auraient la priorité
sur celles définies avec les arguments \code{alter_pos}, \code{alter_neg}, \code{alter_mix}, \code{alter_temporal}, \code{lower_bound} et
\code{upper_bound}).

Les informations sont fournies à l'aide de quatre variables obligatoires (\code{type}, \code{col}, \code{row} et \code{coef}) et d'une
variable facultative (\code{timeVal}). Un enregistrement (une rangée) dans le \emph{data frame} des spécifications du problème
définit soit une étiquette pour l'un des sept types d'éléments du problème d'équilibrage avec les colonnes \code{type} et \code{row}
(voir \emph{Enregistrements de définition d'étiquette} ci-dessous) ou bien spécifie des coefficients (valeurs numériques) pour
ces éléments du problème d'équilibrage avec les variables \code{col}, \code{row}, \code{coef} et \code{timeVal} (voir \emph{Enregistrements de
spécification d'information} ci-dessous).
\itemize{
\item \strong{Enregistrements de définition d'étiquette} (\code{type} n'est pas manquant (n'est pas \code{NA}))
\itemize{
\item \code{type} (car) : mot-clé réservé identifiant le type d'élément du problème en cours de définition :
\itemize{
\item \code{EQ} : contrainte d'équilibrage d'égalité (\eqn{=})
\item \code{LE} : contrainte d'équilibrage d'inégalité de type inférieure ou égale (\eqn{\le}{<=})
\item \code{GE} : contrainte d'équilibrage d'inégalité de type supérieure ou égale (\eqn{\ge}{>=})
\item \code{lowerBd} : borne inférieure des valeurs de période
\item \code{upperBd} : borne supérieure des valeurs de période
\item \code{alter} : coefficient d'altérabilité des valeurs de période
\item \code{alterTmp} : coefficient d'altérabilité des totaux temporels
}
\item \code{row} (car) : étiquette à associer à l'élément du problème (\emph{mot-clé \code{type}})
\item \emph{toutes les autres variables ne sont pas pertinentes et devraient contenir des données manquantes (valeurs \code{NA})} \cr \cr
}
\item \strong{Enregistrements de spécification d'information} (\code{type} est manquant (est \code{NA}))
\itemize{
\item \code{type} (car) : non applicable (\code{NA})
\item \code{col} (car) : nom de la série ou mot réservé \verb{_rhs_} pour spécifier la valeur du côté droit (\emph{RHS} pour
\emph{\strong{R}ight-\strong{H}and \strong{S}ide})
d'une contrainte d'équilibrage.
\item \code{row} (car) : étiquette de l'élément du problème.
\item \code{coef} (num) : valeur de l'élément du problème :
\itemize{
\item coefficient de la série dans la contrainte d'équilibrage ou valeur \emph{RHS}
\item borne inférieure ou supérieure des valeurs de période de la série
\item coefficient d'altérabilité des valeurs de période ou des totaux temporels de la série
}
\item \code{timeVal} (num) : valeur de temps optionnelle pour restreindre l'application des bornes ou coefficients
d'altérabilité des séries à une période (ou groupe temporel) spécifique. Elle correspond à la valeur de temps,
telle que renvoyée par \code{stats::time()}, pour une période (observation) donnée des séries chronologiques d'entrée
(argument \code{in_ts}) et correspond conceptuellement à \eqn{ann\acute{e}e + (p\acute{e}riode - 1) / fr\acute{e}quence}.
}
}

Notez que les chaînes de caractères vides (\code{""} ou \code{''}) pour les variables de type caractère sont interprétées comme
manquantes (\code{NA}) par la fonction. La variable \code{row} identifie les éléments du problème d'équilibrage et est la variable
clé qui fait le lien entre les deux types d'enregistrements. La même étiquette (\code{row}) ne peut être associée à plus d'un
type d'éléments du problème (\code{type}) et plusieurs étiquettes (\code{row}) ne peuvent pas être définies pour un même type
d'éléments du problème donné (\code{type}), à l'exception des contraintes d'équilibrage (valeurs \code{"EQ"}, \code{"LE"} et \code{"GE"} de
la colonne \code{type}). Voici certaines caractéristiques conviviales du \emph{data frame} des spécifications du problème :
\itemize{
\item L'ordre des enregistrements (rangées) n'est pas important.
\item Les valeurs des variables de type caractère (\code{type}, \code{row} et \code{col}) ne sont pas sensibles à la casse (ex., les chaînes de
caractères \code{"Constraint 1"} et \code{"CONSTRAINT 1"} pour la variable \code{row} seraient considérées comme une même étiquette d'élément
du problème), sauf lorsque \code{col} est utilisé pour spécifier un nom de série (une colonne de l'objet d'entrée de type série
chronologique) où \strong{la sensibilité à la casse est appliquée}.
\item Les noms des variables du \emph{data frame} des spécifications du problème ne sont pas non plus sensibles à la casse (ex.,
\code{type}, \code{Type} ou \code{TYPE} sont tous des noms de variable valides) et \code{time_val} est un nom de variable accepté (au lieu de
\code{timeVal}).
}

Enfin, le tableau suivant dresse la liste des alias valides (acceptés) pour les \emph{mots-clés \code{type}}
(type d'éléments du problème) :\tabular{cl}{
   \strong{Mot-clé} \tab \strong{Alias} \cr
   \code{EQ} \tab \code{==}, \code{=} \cr
   \code{LE} \tab \code{<=}, \code{<} \cr
   \code{GE} \tab \code{>=}, \code{>} \cr
   \code{lowerBd} \tab \code{lowerBound}, \code{lowerBnd}, + \emph{mêmes termes avec '_', '.' ou ' ' entre les mots} \cr
   \code{upperBd} \tab \code{upperBound}, \code{upperBnd}, + \emph{mêmes termes avec '_', '.' ou ' ' entre les mots} \cr
   \code{alterTmp} \tab \code{alterTemporal}, \code{alterTemp}, + \emph{mêmes termes avec '_', '.' ou ' ' entre les mots} \cr
}


L'examen des \strong{Exemples} devrait aider à conceptualiser le \emph{data frame} des spécifications du problème d'équilibrage.}

\item{in_ts_name}{(optional)

Chaîne de caractères contenant la valeur de l'argument \code{in_ts}.

\strong{La valeur par défaut} est \code{in_ts_name = deparse1(substitute(in_ts))}.}

\item{ts_freq}{(optional)

Fréquence de l'object the type série chronologique (argument \code{in_ts}).

\strong{La valeur par défaut} est \code{ts_freq = stats::frequency(in_ts)}.}

\item{periods}{(optional)

Vecteur de chaînes de caractères décrivant les périodes de l'object the type série chronologique (argument \code{in_ts}).

\strong{La valeur par défaut} est \code{periods = gs.time2str(in_ts)}.}

\item{n_per}{(optional)

Nombre de périodes de l'object the type série chronologique (argument \code{in_ts}).

\strong{La valeur par défaut} est \code{n_per = nrow(as.matrix(in_ts))}.}

\item{specs_df_name}{(optional)

Chaîne de caractères contenant la valeur de l'argument \code{problem_specs_df}.

\strong{La valeur par défaut} est \code{specs_df_name = deparse1(substitute(problem_specs_df))}.}

\item{temporal_grp_periodicity}{(optionnel)

Nombre entier positif définissant le nombre de périodes dans les groupes temporels pour lesquels les totaux doivent
être préservés. Par exemple, spécifiez \code{temporal_grp_periodicity = 3} avec des séries chronologiques mensuelles pour la
préservation des totaux trimestriels et \code{temporal_grp_periodicity = 12} (ou \code{temporal_grp_periodicity = frequency(in_ts)})
pour la préservation des totaux annuels. Spécifier \code{temporal_grp_periodicity = 1} (\emph{défaut}) correspond à un traitement
période par période sans préservation des totaux temporels.

\strong{La valeur par défaut} est \code{temporal_grp_periodicity = 1} (traitement période par période sans préservation des
totaux temporels).}

\item{alter_pos}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut associé aux valeurs des séries chronologiques
avec des coefficients \strong{positifs} dans toutes les contraintes d'équilibrage dans lesquelles elles sont impliquées (ex.,
les séries composantes dans les problèmes de ratissage (« \emph{raking} ») de tables d'agrégation). Les coefficients
d'altérabilité fournis dans le \emph{data frame} des spécifications du problème (argument \code{problem_specs_df}) remplacent cette
valeur.

\strong{La valeur par défaut} est \code{alter_pos = 1.0} (valeurs non contraignantes).}

\item{alter_neg}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut associé aux valeurs des séries chronologiques
avec des coefficients \strong{négatifs} dans toutes les contraintes d'équilibrage dans lesquelles elles sont impliquées (ex.,
les séries de total de marge dans les problèmes de ratissage (« \emph{raking} ») de tables d'agrégation). Les coefficients
d'altérabilité fournis dans le \emph{data frame} des spécifications du problème (argument \code{problem_specs_df}) remplacent cette
valeur.

\strong{La valeur par défaut} est \code{alter_neg = 1.0} (valeurs non contraignantes).}

\item{alter_mix}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut associé aux valeurs des séries chronologiques
avec un mélange de coefficients \strong{positifs et négatifs} dans les contraintes d'équilibrage dans lesquelles elles sont
impliquées. Les coefficients d'altérabilité fournis dans le \emph{data frame} des spécifications du problème (argument
\code{problem_specs_df}) remplacent cette valeur.

\strong{La valeur par défaut} est \code{alter_mix = 1.0} (valeurs non contraignantes).}

\item{lower_bound}{(optionnel)

Nombre réel spécifiant la borne inférieure par défaut pour les valeurs des séries chronologiques. Les bornes inférieures
fournies dans le \emph{data frame} des spécifications du problème (argument \code{problem_specs_df}) remplacent cette valeur.

\strong{La valeur par défaut} est \code{lower_bound = -Inf} (non borné).}

\item{upper_bound}{(optionnel)

Nombre réel spécifiant la borne supérieure par défaut pour les valeurs des séries chronologiques. Les bornes supérieures
fournies dans le \emph{data frame} des spécifications du problème (argument \code{problem_specs_df}) remplacent cette valeur.

\strong{La valeur par défaut} est \code{upper_bound = Inf} (non borné).}

\item{validation_only}{(optionnel)

Argument logique (\emph{logical}) spécifiant si la fonction doit uniquement effectuer la validation des données d'entrée ou
non. Lorsque \code{validation_only = TRUE}, les \emph{contraintes d'équilibrage} et les \emph{bornes (inférieures et supérieures) des
valeurs de période} spécifiées sont validées par rapport aux données de séries chronologiques d'entrée, en permettant
des écarts jusqu'à la valeur spécifiée avec l'argument \code{validation_tol}. Sinon, lorsque \code{validation_only = FALSE}
(par défaut), les données d'entrée sont d'abord réconciliées et les données résultantes (en sortie) sont ensuite
validées.

\strong{La valeur par défaut} est \code{validation_only = FALSE}.}
}
\value{
Une liste avec les éléments des problèmes d'équilibrage (excluant l'information sur les totaux temporels) :
\itemize{
\item \code{labels_df} : version nettoyée des \emph{enregistrements de définition d'étiquette} provenant de \code{problem_specs_df}
(enregistrements où \code{type} n'est pas manquant (n'est pas \code{NA})); colonnes supplémentaires :
\itemize{
\item \code{type.lc}  : \code{tolower(type)}
\item \code{row.lc}   : \code{tolower(row)}
\item \code{con.flag} : \code{type.lc \%in\% c("eq", "le", "ge")}
}
\item \code{coefs_df}  : version nettoyée des \emph{enregistrements de spécification d'information} provenant de \code{problem_specs_df}
(enregistrements où \code{type} est manquant (est \code{NA})); colonnes supplémentaires :
\itemize{
\item \code{row.lc}   : \code{tolower(row)}
\item \code{con.flag} : \code{labels_df$con.flag} attribuée à travers \code{row.lc}
}
\item \code{values_ts}: version réduite de \code{in_ts} avec seulement les séries pertinentes (voir vecteur \code{ser_names})
\item \code{lb}        : information sur les bornes inférieures (\code{type.lc  = "lowerbd"}) des séries pertinentes; liste avec
les éléments suivants :
\itemize{
\item \code{coefs_ts}        : object « mts » contenant les bornes inférieures des séries pertientes (voir vecteur \code{ser_names})
\item \code{nondated_coefs}  : vecteur des bornes non datées de \code{problem_specs_df} (\code{timeVal} est \code{NA})
\item \code{nondated_id_vec} : vecteur d'identificateurs de \code{ser_names} associés au vecteur \code{nondated_coefs}
\item \code{dated_id_vec}    : vecteur d'identificateurs de \code{ser_names} associés aux bornes inférieures datées de
\code{problem_specs_df} (\code{timeVal} n'est pas \code{NA})
}
\item \code{ub}        : équivalent de \code{lb} pour les bornes supérieures (\code{type.lc = "upperbd"})
\item \code{alter}     : équivalent de \code{lb} pour les coefficients d'altérabilité des valeurs de période (\code{type.lc = "alter"})
\item \code{altertmp}  : équivalent de \code{lb} pour les coefficients d'altérabilité des totaux temporels (\code{type.lc = "altertmp"})
\item \code{ser_names} : vecteur des noms de séries pertinentes (ensemble de séries impliquées dans les contraintes d'équilibrage)
\item \code{pos_ser}   : vecteur des noms de séries qui n'ont que des coefficients non nuls positifs à travers toutes les contraintes
\item \code{neg_ser}   : vecteur des noms de séries qui n'ont que des coefficients non nuls négatifs à travers toutes les contraintes
\item \code{mix_ser}   : vecteur des noms de séries qui ont des coefficients non nuls positifs et négatifs à travers toutes les
contraintes
\item \code{A1},\code{op1},\code{b1} : éléments des contraintes d'équilibrage pour les problèmes impliquant une seule période (ex., chacune des
périodes d'un groupe temporel incomplet)
\item \code{A2},\code{op2},\code{b2} : éléments des contraintes d'équilibrage pour les problèmes impliquant \code{temporal_grp_periodicity} périodes
(ex., l'ensemble des périodes d'un groupe temporel complet)
}
}
\description{
Cette fonction est utilisée à l'interne par \code{\link[=tsbalancing]{tsbalancing()}} pour construire les éléments de base des problèmes
d'équilibrage. Elle peut également être utile pour dériver manuellement les séries indirectes associées aux
contraintes d'équilibrage d'égalité (en dehors du contexte de \code{\link[=tsbalancing]{tsbalancing()}}).
}
\details{
Voir \code{\link[=tsbalancing]{tsbalancing()}} pour une description détaillée des problèmes d'\emph{équilibrage de séries chronologiques}.

Toute valeur manquante (\code{NA}) trouvée dans l'objet de série chronologique d'entrée (argument \code{in_ts}) serait remplacée par 0
dans \code{values_ts} et déclencherait un message d'avertissement.

Les éléments renvoyés des des problèmes d'équilibrage n'incluent pas les totaux temporels implicites (c.-à-d., les éléments
\code{A2}, \code{op2} et \code{b2} ne contiennent que les contraintes d'équilibrage).

Les éléments \code{A2}, \code{op2} et \code{b2} d'un problème d'équilibrage impliquant plusieurs périodes (lorsque
\code{temporal_grp_periodicity > 1}) sont construits \emph{colonne par colonne} (selon le principe « column-major order » en anglais),
ce qui correspond au comportement par défaut de R lors de la conversion d'objets de la classe « matrix » en vecteurs.
Autrement dit, les contraintes d'équilibrage correspondent conceptuellement à :
\itemize{
\item \verb{A1 \%*\% values_ts[t, ] op1 b1} pour des problèmes impliquant une seule période (\code{t})
\item \verb{A2 \%*\% as.vector(values_ts[t1:t2, ]) op2 b2} pour des problèmes impliquant \code{temporal_grp_periodicity} périodes (\code{t1:t2})
}

Notez que l'argument \code{alter_temporal} n'a pas encore été appliqué à ce stade et que \code{altertmp$coefs_ts} ne contient que les
coefficients spécifiés dans le \emph{data frame} des spécifications du problème (argument \code{problem_specs_df}). Autrement dit,
\code{altertmp$coefs_ts} contient des valeurs manquantes (\code{NA}) à l'exception des coefficients d'altérabilité de total temporel
inclus dans (spécifiés avec) \code{problem_specs_df}. Ceci est fait afin de faciliter l'identification du premier coefficient
d'altérabilité non manquant (non \code{NA}) de chaque groupe temporel complet (à survenir ultérieurement, le cas échéant, dans
\code{\link[=tsbalancing]{tsbalancing()}}).
}
\examples{
######################################################################################
#  Cadre de dérivation des séries indirectes avec les métadonnées de `tsbalancing()`
######################################################################################
#
# Il est supposé (convenu) que...
#
# a) Toutes les contraintes d'équilibrage sont des contraintes d'égalité (`type = EQ`).
# b) Toutes les contraintes n'ont qu'une seule série non contraignante (libre) : la 
#    série à dériver (c.-à-d., toutes les séries ont un coef. d'alt. de 0 sauf la 
#    série à dériver).
# c) Chaque contrainte dérive une série différente (une nouvelle série).
# d) Les contraintes sont les mêmes pour toutes les périodes (c.-à-d., il n'y a pas 
#    de coef. d'alt. « datés » spécifiés à l'aide de la colonne `timeVal`).
######################################################################################


# Dériver les totaux de marge d'un cube de données à deux dimensions (2 x 3) en 
# utilisant les métadonnées de `tsbalancing()` (les contraintes d'agrégation d'un 
# cube de données respectent les hypothèses ci-dessus).


# Construire les spécifications du problème d'équilibrage à travers les métadonnées 
# (plus simples) de ratissage.
mes_specs <- rkMeta_to_blSpecs(
  data.frame(series = c("A1", "A2", "A3",
                        "B1", "B2", "B3"),
             total1 = c(rep("totA", 3),
                        rep("totB", 3)),
             total2 = rep(c("tot1", "tot2", "tot3"), 2)),
  alterSeries = 0,  # séries composantes contraignantes (fixes)
  alterTotal1 = 1,  # totaux de marge non contraignants (libres, à dériver)
  alterTotal2 = 1)  # totaux de marge non contraignants (libres, à dériver)
mes_specs

# 6 périodes (trimestres) de données avec totaux de marge initialisés à zéro (0): ces 
# derniers doivent OBLIGATOIREMENT exister dans les données d'entrée ET contenir des 
# données valides (non `NA`).
mes_series <- ts(data.frame(A1 = c(12, 10, 12,  9, 15,  7),
                            B1 = c(20, 21, 15, 17, 19, 18),
                            A2 = c(14,  9,  8,  9, 11, 10),
                            B2 = c(20, 29, 20, 24, 21, 17),
                            A3 = c(13, 15, 17, 14, 16, 12),
                            B3 = c(24, 20, 30, 23, 21, 19),
                            tot1 = rep(0, 6),
                            tot2 = rep(0, 6),
                            tot3 = rep(0, 6),
                            totA = rep(0, 6),
                            totB = rep(0, 6)),
                 start = 2019, frequency = 4)

# Obtenir les éléments du problème d'équilibrage.
n_per <- nrow(mes_series)
p <- build_balancing_problem(mes_series, mes_specs, 
                             temporal_grp_periodicity = n_per)

# `A2`, `op2` et `b2` définissent 30 constraintes (5 totaux de marge X 6 périodes) 
# impliquant un total de 66 points de données (11 séries X 6 périodes) desquels 36 
# réfèrent aux 6 séries composantes et 30 réfèrent aux 5 totaux de marge.
dim(p$A2)

# Obtenir les noms des totaux de marge (séries avec un coef. d'alt. non nul), dans 
# l'ordre où les contraintes correspondantes apparaissent dans les spécifications 
# (ordre de spécification des constraintes).
tmp <- p$coefs_df$col[p$coefs_df$con.flag]
noms_tot <- tmp[tmp \%in\% p$ser_names[p$alter$nondated_id_vec[p$alter$nondated_coefs != 0]]]

# Définir des drapeaux logiques identifiant les colonnes de total de marge :
# - `col_tot_logi1` : éléments à période unique (de longueur 11 = nombre de séries)
# - `col_tot_logi2` : éléments multi-périodes (de longueur 66 = nombre de points de
#                     données), selon le principe « column-major order » en anglais 
#                     (l'ordre de construction des éléments de la matrice `A2`)
col_tot_logi1 <- p$ser_names \%in\% noms_tot
col_tot_logi2 <- rep(col_tot_logi1, each = n_per)

# Ordre des totaux de marge à dériver selon
# ... les colonnes des données d'entrée (objet « mts » `mes_series`)
p$ser_names[col_tot_logi1]
# ... la spécification des contraintes (« data frame » `mes_specs`)
noms_tot


# Calculer les 5 totaux de marge pour les 6 périodes.
# Note : le calcul suivant prend en compte les contraintes d'égalité linéaires 
#        générales, c.-à-d.,
#        a) des valeurs non nulles du côté droit des contraintes (`b2`) et 
#        b) des coefficients de contrainte non nuls autres que 1 pour les séries 
#           composantes et -1 pour la série à dériver. 
mes_series[, noms_tot] <- {
  (
    # Côté droit des contraintes
    p$b2 - 

    # Sommes des composantes (« pondérées » par les coefficients des contraintes)
    p$A2[, !col_tot_logi2, drop = FALSE] \%*\% as.vector(p$values_ts[, !col_tot_logi1])
  ) /

  # Coefficients des séries dérivées : `t()` permet une recherche « par ligne » dans 
  # la matrice `A2` (c.-à-d., selon l'ordre de spécification des constraintes)
  # Note: `diag(p$A2[, tot_col_logi2])` fonctionnerait si `p$ser_names[col_tot_logi1]` 
  #       et `noms_tot` étaient identiques (même ordre pour les totaux); par contre, 
  #       la recherche « par ligne » ci-dessous fonctionnera toujours (et est 
  #       nécessaire dans le cas qui nous concerne).
  t(p$A2[, col_tot_logi2])[t(p$A2[, col_tot_logi2]) != 0]
}
mes_series
}
\seealso{
\code{\link[=tsbalancing]{tsbalancing()}} \code{\link[=build_raking_problem]{build_raking_problem()}}
}
