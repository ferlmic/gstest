% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsbalancing.R
\name{tsbalancing}
\alias{tsbalancing}
\title{Rétablir les contraintes linéaires transversales (contemporaines)}
\usage{
tsbalancing(
  in_ts,
  problem_specs_df,
  temporal_grp_periodicity = 1,
  temporal_grp_start = 1,
  osqp_settings_df = default_osqp_sequence,
  display_level = 1,
  alter_pos = 1,
  alter_neg = 1,
  alter_mix = 1,
  alter_temporal = 0,
  lower_bound = -Inf,
  upper_bound = Inf,
  tolV = 0,
  tolV_temporal = 0,
  tolP_temporal = NA,

  # Nouveau dans G-Séries 3.0
  validation_tol = 0.001,
  trunc_to_zero_tol = validation_tol,
  full_sequence = FALSE,
  validation_only = FALSE,
  quiet = FALSE
)
}
\arguments{
\item{in_ts}{(obligatoire)

Objet de type série chronologique (« ts » ou « mts »), ou objet compatible, qui contient les données des séries
chronologiques à réconcilier. Il s'agit des données d'entrée (solutions initiales) des problèmes d'équilibrage
(« \emph{balancing} »).}

\item{problem_specs_df}{(obligatoire)

\emph{Data frame} des spécifications du problème d'équilibrage. En utilisant un format clairsemé (épars) inspiré de la
procédure LP de SAS/OR\eqn{^\circledR}{®} (SAS Institute 2015), il ne contient que les informations pertinentes
telles que les coefficients non nuls des contraintes d'équilibrage ainsi que les coefficients d'altérabilité et les
bornes inférieures/supérieures à utiliser au lieu des valeurs par défaut (c.-à-d., les valeurs qui auraient la priorité
sur celles définies avec les arguments \code{alter_pos}, \code{alter_neg}, \code{alter_mix}, \code{alter_temporal}, \code{lower_bound} et
\code{upper_bound}).

Les informations sont fournies à l'aide de quatre variables obligatoires (\code{type}, \code{col}, \code{row} et \code{coef}) et d'une
variable facultative (\code{timeVal}). Un enregistrement (une rangée) dans le \emph{data frame} des spécifications du problème
définit soit une étiquette pour l'un des sept types d'éléments du problème d'équilibrage avec les colonnes \code{type} et \code{row}
(voir \emph{Enregistrements de définition d'étiquette} ci-dessous) ou bien spécifie des coefficients (valeurs numériques) pour
ces éléments du problème d'équilibrage avec les variables \code{col}, \code{row}, \code{coef} et \code{timeVal} (voir \emph{Enregistrements de
spécification d'information} ci-dessous).
\itemize{
\item \strong{Enregistrements de définition d'étiquette} (\code{type} n'est pas manquant (n'est pas \code{NA}))
\itemize{
\item \code{type} (car) : mot-clé réservé identifiant le type d'élément du problème en cours de définition :
\itemize{
\item \code{EQ} : contrainte d'équilibrage d'égalité (\eqn{=})
\item \code{LE} : contrainte d'équilibrage d'inégalité de type inférieure ou égale (\eqn{\le}{<=})
\item \code{GE} : contrainte d'équilibrage d'inégalité de type supérieure ou égale (\eqn{\ge}{>=})
\item \code{lowerBd} : borne inférieure des valeurs de période
\item \code{upperBd} : borne supérieure des valeurs de période
\item \code{alter} : coefficient d'altérabilité des valeurs de période
\item \code{alterTmp} : coefficient d'altérabilité des totaux temporels
}
\item \code{row} (car) : étiquette à associer à l'élément du problème (\emph{mot-clé \code{type}})
\item \emph{toutes les autres variables ne sont pas pertinentes et devraient contenir des données manquantes (valeurs \code{NA})} \cr \cr
}
\item \strong{Enregistrements de spécification d'information} (\code{type} est manquant (est \code{NA}))
\itemize{
\item \code{type} (car) : non applicable (\code{NA})
\item \code{col} (car) : nom de la série ou mot réservé \verb{_rhs_} pour spécifier la valeur du côté droit (\emph{RHS} pour
\emph{\strong{R}ight-\strong{H}and \strong{S}ide})
d'une contrainte d'équilibrage.
\item \code{row} (car) : étiquette de l'élément du problème.
\item \code{coef} (num) : valeur de l'élément du problème :
\itemize{
\item coefficient de la série dans la contrainte d'équilibrage ou valeur \emph{RHS}
\item borne inférieure ou supérieure des valeurs de période de la série
\item coefficient d'altérabilité des valeurs de période ou des totaux temporels de la série
}
\item \code{timeVal} (num) : valeur de temps optionnelle pour restreindre l'application des bornes ou coefficients
d'altérabilité des séries à une période (ou groupe temporel) spécifique. Elle correspond à la valeur de temps,
telle que renvoyée par \code{stats::time()}, pour une période (observation) donnée des séries chronologiques d'entrée
(argument \code{in_ts}) et correspond conceptuellement à \eqn{ann\acute{e}e + (p\acute{e}riode - 1) / fr\acute{e}quence}.
}
}

Notez que les chaînes de caractères vides (\code{""} ou \code{''}) pour les variables de type caractère sont interprétées comme
manquantes (\code{NA}) par la fonction. La variable \code{row} identifie les éléments du problème d'équilibrage et est la variable
clé qui fait le lien entre les deux types d'enregistrements. La même étiquette (\code{row}) ne peut être associée à plus d'un
type d'éléments du problème (\code{type}) et plusieurs étiquettes (\code{row}) ne peuvent pas être définies pour un même type
d'éléments du problème donné (\code{type}), à l'exception des contraintes d'équilibrage (valeurs \code{"EQ"}, \code{"LE"} et \code{"GE"} de
la colonne \code{type}). Voici certaines caractéristiques conviviales du \emph{data frame} des spécifications du problème :
\itemize{
\item L'ordre des enregistrements (rangées) n'est pas important.
\item Les valeurs des variables de type caractère (\code{type}, \code{row} et \code{col}) ne sont pas sensibles à la casse (ex., les chaînes de
caractères \code{"Constraint 1"} et \code{"CONSTRAINT 1"} pour la variable \code{row} seraient considérées comme une même étiquette d'élément
du problème), sauf lorsque \code{col} est utilisé pour spécifier un nom de série (une colonne de l'objet d'entrée de type série
chronologique) où \strong{la sensibilité à la casse est appliquée}.
\item Les noms des variables du \emph{data frame} des spécifications du problème ne sont pas non plus sensibles à la casse (ex.,
\code{type}, \code{Type} ou \code{TYPE} sont tous des noms de variable valides) et \code{time_val} est un nom de variable accepté (au lieu de
\code{timeVal}).
}

Enfin, le tableau suivant dresse la liste des alias valides (acceptés) pour les \emph{mots-clés \code{type}}
(type d'éléments du problème) :\tabular{cl}{
   \strong{Mot-clé} \tab \strong{Alias} \cr
   \code{EQ} \tab \code{==}, \code{=} \cr
   \code{LE} \tab \code{<=}, \code{<} \cr
   \code{GE} \tab \code{>=}, \code{>} \cr
   \code{lowerBd} \tab \code{lowerBound}, \code{lowerBnd}, + \emph{mêmes termes avec '_', '.' ou ' ' entre les mots} \cr
   \code{upperBd} \tab \code{upperBound}, \code{upperBnd}, + \emph{mêmes termes avec '_', '.' ou ' ' entre les mots} \cr
   \code{alterTmp} \tab \code{alterTemporal}, \code{alterTemp}, + \emph{mêmes termes avec '_', '.' ou ' ' entre les mots} \cr
}


L'examen des \strong{Exemples} devrait aider à conceptualiser le \emph{data frame} des spécifications du problème d'équilibrage.}

\item{temporal_grp_periodicity}{(optionnel)

Nombre entier positif définissant le nombre de périodes dans les groupes temporels pour lesquels les totaux doivent
être préservés. Par exemple, spécifiez \code{temporal_grp_periodicity = 3} avec des séries chronologiques mensuelles pour la
préservation des totaux trimestriels et \code{temporal_grp_periodicity = 12} (ou \code{temporal_grp_periodicity = frequency(in_ts)})
pour la préservation des totaux annuels. Spécifier \code{temporal_grp_periodicity = 1} (\emph{défaut}) correspond à un traitement
période par période sans préservation des totaux temporels.

\strong{La valeur par défaut} est \code{temporal_grp_periodicity = 1} (traitement période par période sans préservation des
totaux temporels).}

\item{temporal_grp_start}{(optionnel)

Entier dans l'intervalle [1 .. \code{temporal_grp_periodicity}] spécifiant la période (cycle) de départ pour la préservation
des totaux temporels. Par exemple, des totaux annuels correspondant aux années financières définies d'avril à mars de l'année
suivante seraient spécifiés avec \code{temporal_grp_start = 4} pour des séries chronologiques mensuelles (\code{frequency(in_ts) = 12})
et \code{temporal_grp_start = 2} pour des séries chronologiques trimestrielles (\code{frequency(in_ts) = 4}). Cet argument n'a pas
d'effet pour un traitement période par période sans préservation des totaux temporels (\code{temporal_grp_periodicity = 1}).

\strong{La valeur par défaut} est \code{temporal_grp_start = 1}.}

\item{osqp_settings_df}{(optionnel)

\emph{Data frame} contenant une séquence de paramètres d'OSQP pour la résolution des problèmes d'équilibrage. La librairie
inclut deux \emph{data frames} prédéfinis de séquences de paramètres d'OSQP :
\itemize{
\item \link{default_osqp_sequence} : rapide et efficace (par défaut);
\item \link{alternate_osqp_sequence} : orienté vers la précision au détriment du temps d'exécution.
}

Voir la \code{vignette("osqp-settings-sequence-dataframe")} pour plus de détails sur ce sujet et pour voir le contenu de ces
deux \emph{data frames}. Notez que le concept d'une \emph{séquence de résolution} avec différents ensembles de paramètres pour
le solveur est nouveau dans G-Séries 3.0 (une seule tentative de résolution était effectuée dans G-Séries 2.0).

\strong{La valeur par défaut} est \code{osqp_settings_df = default_osqp_sequence}.}

\item{display_level}{(optionnel)

Entier dans l'intervalle [0 .. 3] spécifiant le niveau d'information à afficher dans la console (\code{stdout()}).
Notez que spécifier l'argument \code{quiet = TRUE} annulerait l'argument \code{display_level} (aucune des informations suivantes
ne serait affichée).\tabular{lcccc}{
   \strong{Information affichée} \tab \strong{\code{0}} \tab \strong{\code{1}} \tab \strong{\code{2}} \tab \strong{\code{3}} \cr
   En-tête de la fonction \tab \eqn{\checkmark}{Y} \tab \eqn{\checkmark}{Y} \tab \eqn{\checkmark}{Y} \tab \eqn{\checkmark}{Y} \cr
   Éléments du problème d'équilibrage \tab  \tab \eqn{\checkmark}{Y} \tab \eqn{\checkmark}{Y} \tab \eqn{\checkmark}{Y} \cr
   Détails de résolution de chaque problème \tab  \tab  \tab \eqn{\checkmark}{Y} \tab \eqn{\checkmark}{Y} \cr
   Résultats de chaque problème (valeurs et contraintes) \tab  \tab  \tab  \tab \eqn{\checkmark}{Y} \cr
}


\strong{La valeur par défaut} est \code{display_level = 1}.}

\item{alter_pos}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut associé aux valeurs des séries chronologiques
avec des coefficients \strong{positifs} dans toutes les contraintes d'équilibrage dans lesquelles elles sont impliquées (ex.,
les séries composantes dans les problèmes de ratissage (« \emph{raking} ») de tables d'agrégation). Les coefficients
d'altérabilité fournis dans le \emph{data frame} des spécifications du problème (argument \code{problem_specs_df}) remplacent cette
valeur.

\strong{La valeur par défaut} est \code{alter_pos = 1.0} (valeurs non contraignantes).}

\item{alter_neg}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut associé aux valeurs des séries chronologiques
avec des coefficients \strong{négatifs} dans toutes les contraintes d'équilibrage dans lesquelles elles sont impliquées (ex.,
les séries de total de marge dans les problèmes de ratissage (« \emph{raking} ») de tables d'agrégation). Les coefficients
d'altérabilité fournis dans le \emph{data frame} des spécifications du problème (argument \code{problem_specs_df}) remplacent cette
valeur.

\strong{La valeur par défaut} est \code{alter_neg = 1.0} (valeurs non contraignantes).}

\item{alter_mix}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut associé aux valeurs des séries chronologiques
avec un mélange de coefficients \strong{positifs et négatifs} dans les contraintes d'équilibrage dans lesquelles elles sont
impliquées. Les coefficients d'altérabilité fournis dans le \emph{data frame} des spécifications du problème (argument
\code{problem_specs_df}) remplacent cette valeur.

\strong{La valeur par défaut} est \code{alter_mix = 1.0} (valeurs non contraignantes).}

\item{alter_temporal}{(optionnel)

Nombre réel non négatif spécifiant le coefficient d'altérabilité par défaut associé aux totaux temporels des séries
chronologiques. Les coefficients d'altérabilité fournis dans le \emph{data frame} des spécifications du problème (argument
\ifelse{latex}{\code{problem _specs_df}}{\code{problem_specs_df}}) remplacent cette valeur.

\strong{La valeur par défaut} est \code{alter_temporal = 0.0} (valeurs contraignantes).}

\item{lower_bound}{(optionnel)

Nombre réel spécifiant la borne inférieure par défaut pour les valeurs des séries chronologiques. Les bornes inférieures
fournies dans le \emph{data frame} des spécifications du problème (argument \code{problem_specs_df}) remplacent cette valeur.

\strong{La valeur par défaut} est \code{lower_bound = -Inf} (non borné).}

\item{upper_bound}{(optionnel)

Nombre réel spécifiant la borne supérieure par défaut pour les valeurs des séries chronologiques. Les bornes supérieures
fournies dans le \emph{data frame} des spécifications du problème (argument \code{problem_specs_df}) remplacent cette valeur.

\strong{La valeur par défaut} est \code{upper_bound = Inf} (non borné).}

\item{tolV}{(optionnel)

Nombre réel non négatif spécifiant la tolérance, en valeur absolue, de la valeur du côté droit (\emph{RHS}) des contraintes
d'équilibrage :
\itemize{
\item Contraintes \code{EQ} : \eqn{\quad A\mathbf{x} = \mathbf{b} \quad}{Ax = b} devient \eqn{\quad \mathbf{b} - \epsilon \le 
A\mathbf{x} \le \mathbf{b} + \epsilon}{b - eps <= Ax <= b + eps}
\item Contraintes \code{LE} : \eqn{\quad A\mathbf{x} \le \mathbf{b} \quad}{Ax <= b} devient \eqn{\quad A\mathbf{x} \le 
\mathbf{b} + \epsilon}{Ax <= b + eps}
\item Contraintes \code{GE} : \eqn{\quad A\mathbf{x} \ge \mathbf{b} \quad}{Ax >= b} devient \eqn{\quad A\mathbf{x} \ge 
\mathbf{b} - \epsilon}{Ax >= b - eps}
}

où \eqn{\epsilon}{eps} est la tolérance spécifiée avec \code{tolV}. Cet argument ne s'applique pas aux \emph{bornes (inférieures et
supérieures) des valeurs de période} spécifiées avec les arguments \code{lower_bound} et \code{upper_bound} ou dans le \emph{data frame}
des spécifications du problème (argument \code{prob_specs_df}). Autrement dit, \code{tolV} n'affecte pas les bornes inférieure et
supérieure des valeurs des séries chronologiques, à moins qu'elles ne soient spécifiées comme \emph{contraintes d'équilibrage}
à la place (avec des contraintes \code{GE} et \code{LE} dans le \emph{data frame} des spécifications du problème).

\strong{La valeur par défaut} est \code{tolV = 0.0} (pas de tolérance).}

\item{tolV_temporal, tolP_temporal}{(optionnel)

Nombre réel non négatif, ou \code{NA}, spécifiant la tolérance, en pourcentage (\code{tolP_temporal}) ou en valeur absolue
(\code{tolV_temporal}), pour les contraintes implicites d'agrégation temporelle associées aux \strong{totaux temporels contraignants}
\eqn{\left( \sum_t{x_{i,t}} = \sum_t{y_{i,t}} \right)}{(sum_t{x_{i,t}} = sum_t{y_{i,t}})}, qui deviennent :
\deqn{\sum_t{y_{i,t}} - \epsilon_\text{abs} \le \sum_t{x_{i,t}} \le \sum_t{y_{i,t}} + \epsilon_\text{abs}}{sum_t{y_{i,t}} - 
eps_abs <= sum_t{x_{i,t}} <= sum_t{y_{i,t}} + eps_abs}
ou
\deqn{\sum_t{y_{i,t}} \left( 1 - \epsilon_\text{rel} \right) \le \sum_t{x_{i,t}} \le \sum_t{y_{i,t}} \left( 1 + 
\epsilon_\text{rel} \right)}{sum_t{y_{i,t}} (1 - eps_rel) <= sum_t{x_{i,t}} <= sum_t{y_{i,t}} (1 + eps_rel)}

où \eqn{\epsilon_\text{abs}}{eps_abs} et \eqn{\epsilon_\text{rel}}{eps_rel} sont les tolérances absolues et en pourcentage
spécifiées respectivement avec \code{tolV_temporal} et \code{tolP_temporal}. Les deux arguments ne peuvent pas être spécifiés tous
les deux à la fois (l'un doit être spécifié tandis que l'autre doit être \code{NA}).

\strong{Exemple :} pour une tolérance de 10 \emph{unités}, spécifiez \code{tolV_temporal = 10, tolP_temporal = NA}; pour une tolérance
de 1\%, spécifiez \code{tolV_temporal = NA, tolP_temporal = 0.01}.

\strong{Les valeurs par défaut} sont \code{tolV_temporal = 0.0} et \code{tolP_temporal = NA} (pas de tolérance).}

\item{validation_tol}{(optionnel)

Nombre réel non négatif spécifiant la tolérance pour la validation des résultats d'équilibrage. La fonction vérifie si
les valeurs finales des séries chronologiques (réconciliées) satisfont les contraintes, en autorisant des écarts jusqu'à
la valeur spécifiée avec cet argument. Un avertissement est émis dès qu'une contrainte n'est pas respectée (écart
supérieur à \code{validation_tol}).

Avec des contraintes définies comme \eqn{\mathbf{l} \le A\mathbf{x} \le \mathbf{u}}{l <= Ax <= u}, où \eqn{\mathbf{l = 
u}}{l = u} pour les contraintes \code{EQ}, \eqn{\mathbf{l} = -\infty}{l = -Inf} pour les contraintes \code{LE} et \eqn{\mathbf{u} = 
\infty}{u = Inf} pour les contraintes \code{GE}, \strong{les écarts de contraintes} correspondent à \eqn{\max \left( 0, \mathbf{l} - 
A\mathbf{x}, A\mathbf{x} - \mathbf{u} \right)}{max(0, l - Ax, Ax - u)}, où les bornes de contraintes \eqn{\mathbf{l}}{l}
et \eqn{\mathbf{u}}{u} incluent les tolérances, le cas échéant, spécifiées avec les arguments \code{tolV}, \code{tolV_temporal} et
\code{tolP_temporal}.

\strong{La valeur par défaut} est \code{validation_tol = 0.001}.}

\item{trunc_to_zero_tol}{(optionnel)

Nombre réel non négatif spécifiant la tolérance, en valeur absolue, pour le remplacement par zéro de (petites) valeurs
dans les données (réconciliées) de séries chronologiques de sortie (objet de sortie \code{out_ts}). Spécifiez
\code{trunc_to_zero_tol = 0} pour désactiver ce processus de \emph{troncation à zéro} des données réconciliées. Sinon, spécifiez
\code{trunc_to_zero_tol > 0} pour remplacer par \eqn{0.0} toute valeur dans l'intervalle \eqn{\left[ -\epsilon, \epsilon 
\right]}{[-eps, eps]}, où \eqn{\epsilon}{eps} est la tolérance spécifiée avec \code{trunc_to_zero_tol}.

Notez que les écarts de contraintes finaux (voir l'argument \code{validation_tol}) sont calculées sur les séries
chronologiques réconciliées \emph{tronquées à zéro}, ce qui garantit une validation précise des données réconciliées
réelles renvoyées par la fonction.

\strong{La valeur par défaut} est \code{trunc_to_zero_tol = validation_tol}.}

\item{full_sequence}{(optionnel)

Argument logique (\emph{logical}) spécifiant si toutes les étapes du \emph{data frame pour la séquence de paramètres d'OSQP}
doivent être exécutées ou non.  Voir l'argument \code{osqp_settings_df} et la \code{vignette("osqp-settings-sequence-dataframe")}
pour plus de détails sur ce sujet.

\strong{La valeur par défaut} est \code{full_sequence = FALSE}.}

\item{validation_only}{(optionnel)

Argument logique (\emph{logical}) spécifiant si la fonction doit uniquement effectuer la validation des données d'entrée ou
non. Lorsque \code{validation_only = TRUE}, les \emph{contraintes d'équilibrage} et les \emph{bornes (inférieures et supérieures) des
valeurs de période} spécifiées sont validées par rapport aux données de séries chronologiques d'entrée, en permettant
des écarts jusqu'à la valeur spécifiée avec l'argument \code{validation_tol}. Sinon, lorsque \code{validation_only = FALSE}
(par défaut), les données d'entrée sont d'abord réconciliées et les données résultantes (en sortie) sont ensuite
validées.

\strong{La valeur par défaut} est \code{validation_only = FALSE}.}

\item{quiet}{(optionnel)

Argument logique (\emph{logical}) spécifiant s'il faut ou non afficher uniquement les informations essentielles telles que
les avertissements, les erreurs et la période (ou l'ensemble de périodes) en cours de traitement. Vous pouvez également
supprimer, si vous le souhaitez, l'affichage des informations relatives à la (aux) période(s) en cours de traitement en
\emph{enveloppant} votre appel à \code{\link[=tsbalancing]{tsbalancing()}} avec \code{\link[=suppressMessages]{suppressMessages()}}. Dans ce cas, le \emph{data frame} de sortie
\strong{proc_grp_df} peut être utilisé pour identifier les problèmes d'équilibrage (infructueux) associés aux messages
d'avertissement (le cas échéant). Notez que la spécification de \code{quiet = TRUE} annulera également l'argument \code{display_level}.

\strong{La valeur par défaut} est \code{quiet = FALSE}.}
}
\value{
La fonction renvoie une liste de sept objets :
\itemize{
\item \strong{out_ts} : version modifiée de l'objet d'entrée de type série chronologique (« ts » ou « mts »; voir l'argument \code{in_ts})
contenant les valeurs réconciliées des séries chronologiques qui résultent de l'exécution de la fonction (sortie
principale de la fonction). Il peut être explicitement converti en un autre type d'objet avec la fonction \verb{as*()}
appropriée (ex., \code{tsibble::as_tsibble()} le convertirait en tsibble).
\item \strong{proc_grp_df} : \emph{data frame} récapitulatif des groupes de traitement, utile pour identifier les problèmes
fructueux ou infructueux. Il contient un enregistrement (une rangée) pour chaque problème d'équilibrage avec les
colonnes suivantes :
\itemize{
\item \code{proc_grp} (num) : identificateur du groupe de traitement.
\item \code{proc_grp_type} (car) : type de groupe de traitement. Les valeurs possibles sont :
\itemize{
\item \code{"period"} (périodes uniques);
\item \code{"temporal group"} (groupes temporels).
}
\item \code{proc_grp_label} (car) : chaîne de caractères décrivant le groupe de traitement dans le format suivant :
\itemize{
\item \code{"<year>-<period>"} (périodes uniques)
\item \code{"<start year>-<start period> - <end year>-<end period>"} (groupes temporels)
}
\item \code{sol_status_val}, \code{sol_status} (num, car) : valeur numérique (entière) et chaîne de caractères associés au
statut de la solution :
\itemize{
\item \code{ 1} : \code{"valid initial solution"} (solution initiale valide);
\item \code{-1} : \code{"invalid initial solution"} (solution initiale invalide);
\item \code{ 2} : \code{"valid polished osqp solution"} (solution OSQP \emph{raffinée} valide);
\item \code{-2} : \code{"invalid polished osqp solution"} (solution OSQP \emph{raffinée} invalide);
\item \code{ 3} : \code{"valid unpolished osqp solution"} (solution OSQP \emph{non raffinée} valide);
\item \code{-3} : \code{"invalid unpolished osqp solution"} (solution OSQP \emph{non raffinée} invalide);
\item \code{-4} : \code{"unsolvable fixed problem"} (problème fixe insoluble, avec solution initiale invalide).
}
\item \code{n_unmet_con} (num) : nombre de contraintes non satisfaites (\code{sum(prob_conf_df$unmet_flag)}).
\item \code{max_discr} (num) : écart de contrainte maximal (\code{max(prob_conf_df$discr_out)}).
\item \code{validation_tol} (num) : tolérance spécifiée à des fins de validation (argument \code{validation_tol}).
\item \code{sol_type} (car) : type de solution renvoyée. Les valeurs possibles sont :
\itemize{
\item \code{"initial"} (solution initiale, c.-à-d., les valeurs des données d'entrée);
\item \code{"osqp"} (solution OSQP).
}
\item \code{osqp_attempts} (num) : nombre de tentatives effectuées avec OSQP (profondeur atteinte dans la séquence
de résolution).
\item \code{osqp_seqno} (num) : numéro d'étape de la séquence de résolution correspondant à la solution renvoyée.
\code{NA} lorsque \code{sol_type = "initial"}.
\item \code{osqp_status} (car) : chaîne de caractères décrivant le statut OSQP (\code{osqp_sol_info_df$status}). \code{NA} lorsque
\code{sol_type = "initial"}.
\item \code{osqp_polished} (logi) : \code{TRUE} si la solution OSQP renvoyée est \emph{raffinée} (\ifelse{latex}{
  \code{osqp_sol_info_df $status_polish = 1}}{\code{osqp_sol_info_df$status_polish = 1}}), \code{FALSE} sinon.
\code{NA} lorsque \code{sol_type = "initial"}.
\item \code{total_solve_time} (num) : temps total, en secondes, de la séquence de résolution.
}

La colonne \code{proc_grp} constitue une \emph{clé unique} (enregistrements distincts) pour le \emph{data frame}. Les problèmes
d'équilibrage fructueux (problèmes avec une solution valide) correspondent aux enregistrements avec
\code{sol_status_val > 0} ou, de manière équivalente, à \code{n_unmet_con = 0} ou à \code{max_discr <= validation_tol}. La
\emph{solution initiale} (\code{sol_type = "initial"}) n'est renvoyée que si \strong{a)} il n'y a pas de d'écarts de contraintes
initiaux, \strong{b)} le problème est fixé (toutes les valeurs sont contraignantes) ou \strong{c)} elle est meilleure que la
solution OSQP (total des écarts de contraintes plus faible). La séquence de résolution est décrite dans la
\ifelse{latex}{\code{vignette("osqp-settings -sequence-dataframe")}}{\code{vignette("osqp-settings-sequence-dataframe")}}.
\item \strong{periods_df} : \emph{data frame} sur les périodes de temps, utile pour faire correspondre les périodes aux groupes
de traitement. Il contient un enregistrement (une rangée) pour chaque période de l'objet d'entrée de type série
chronologique (argument \code{in_ts}) avec les colonnes suivantes :
\itemize{
\item \code{proc_grp} (num) : identificateur du groupe de traitement.
\item \code{t} (num) : identificateur de la période (\code{1:nrow(in_ts)}).
\item \code{time_val} (num) : valeur de temps (\code{stats::time(in_ts)}). Correspond conceptuellement à \eqn{ann\acute{e}e + 
  (p\acute{e}riode - 1) / fr\acute{e}quence}.
}

Les colonnes \code{t} et \code{time_val} constituent toutes deux une \emph{clé unique} (enregistrements distincts) pour le
\emph{data frame}.
\item \strong{prob_val_df} : \emph{data frame} sur les valeurs du problème, utile pour analyser les changements entre les valeurs
initiales et finales (réconciliées). Il contient un enregistrement (une rangée) pour chaque valeur impliquée dans
chaque problème d'équilibrage, avec les colonnes suivantes :
\itemize{
\item \code{proc_grp} (num) : identificateur du groupe de traitement.
\item \code{val_type} (car) : type de valeur du problème. Les valeurs possibles sont :
\itemize{
\item \code{"period value"} (valeur de période);
\item \code{"temporal total"} (total temporel).
}
\item \code{name} (car) : nom de la série chronologique (variable).
\item \code{t} (num) : identificateur de la période (\code{1:nrow(in_ts)}); identificateur de la première période du groupe
temporel pour un \emph{total temporel}.
\item \code{time_val} (num) : valeur de temps (\code{stats::time(in_ts)}); valeur de la première période du groupe temporel
pour un \emph{total temporel}. Correspond conceptuellement à \eqn{ann\acute{e}e + (p\acute{e}riode - 1) / fr\acute{e}quence}.
\item \code{lower_bd}, \code{upper_bd} (num) : bornes des valeurs de période; toujours \code{-Inf} et \code{Inf} pour un \emph{total temporel}.
\item \code{alter} (num) : coefficient d'altérabilité.
\item \code{value_in}, \code{value_out} (num) : valeurs initiales et finales (réconciliées).
\item \code{dif} (num) : \code{value_out - value_in}.
\item \code{rdif} (num) : \code{dif / value_in}; \code{NA} si \code{value_in = 0}.
}

Les colonnes \code{val_type + name + t} et \code{val_type + name + time_val} constituent toutes deux une \emph{clé unique}
(enregistrements distincts) pour le \emph{data frame}. Les valeurs contraignantes (fixes) des problèmes correspondent aux
enregistrements avec \code{alter = 0} ou \code{value_in = 0}. Inversement, les valeurs de problèmes non contraignantes (libres)
correspondent aux enregistrements avec \code{alter != 0} et \code{value_in != 0}.
\item \strong{prob_con_df} : \emph{data frame} sur les contraintes du problème, utile pour dépanner les problèmes infructueux (identifier
les contraintes non satisfaites). Il contient un enregistrement (une rangée) pour chaque contrainte impliquée dans chaque
problème d'équilibrage, avec les colonnes suivantes :
\itemize{
\item \code{proc_grp} (num) : identificateur du groupe de traitement.
\item \code{con_type} (car) : type de contrainte. Les valeurs possibles sont :
\itemize{
\item \code{"balancing constraint"} (contrainte d'équilibrage);
\item \code{"temporal aggregation constraint"} (contrainte d'agrégation temporelle);
\item \code{"period value bounds"} (bornes de valeur de période).
}

Alors que les \emph{contraintes d'équilibrage} sont spécifiées par l'utilisateur, les deux autres types de contraintes
(\emph{contraintes d'agrégation temporelle} et \emph{bornes de valeur de période}) sont automatiquement ajoutées au problème
par la fonction (le cas échéant).
\item \code{name} (car) : étiquette de la contrainte ou nom de la série chronologique (variable).
\item \code{t} (num) : identificateur de la période (\code{1:nrow(in_ts)}); identificateur de la première période du groupe
temporel pour une \emph{contrainte d'agrégation temporelle}.
\item \code{time_val} (num) : valeur de temps (\code{stats::time(in_ts)}); valeur de la première période du groupe temporel
pour une \emph{contrainte d'agrégation temporelle}. Correspond conceptuellement à \eqn{ann\acute{e}e + (p\acute{e}riode - 1) 
  / fr\acute{e}quence}.
\item \code{l}, \code{u}, \code{Ax_in}, \code{Ax_out} (num) : éléments de contrainte initiaux et finaux \eqn{\left( \mathbf{l} \le A \mathbf{x} 
  \le \mathbf{u} \right)}{(l <= Ax <= u)}.
\item \code{discr_in}, \code{discr_out} (num) : écarts de contrainte initiaux et finaux \eqn{\left( \max \left( 0, \mathbf{l} - A 
  \mathbf{x}, A \mathbf{x} - \mathbf{u} \right) \right)}{(max(0, l - Ax, Ax - u))}.
\item \code{validation_tol} (num) : tolérance spécifiée à des fins de validation (argument \code{validation_tol}).
\item \code{unmet_flag} (logi) : \code{TRUE} si la contrainte n'est pas satisfaite (\code{discr_out > validation_tol}), \code{FALSE} sinon.
}

Les colonnes \code{con_type + name + t} et \code{con_type + name + time_val} constituent toutes deux une \emph{clé unique}
(enregistrements distincts) pour le \emph{data frame}. Les bornes de contrainte \eqn{\mathbf{l = u}}{l = u} pour des
contraintes \code{EQ}, \eqn{\mathbf{l} = -\infty}{l = -Inf} pour des contraintes \code{LE}, \eqn{\mathbf{u} = \infty}{u = Inf}
pour des contraintes \code{GE}, et incluent les tolérances, le cas échéant, spécifiées avec les arguments \code{tolV},
\code{tolV_temporal} et \code{tolP_temporal}.
\item \strong{osqp_settings_df} : \emph{data frame} des paramètres d'OSQP. Il contient un enregistrement (une rangée) pour chaque
problème (groupe de traitement) résolu avec OSQP (\code{proc_grp_df$sol_type = "osqp"}), avec les colonnes suivantes :
\itemize{
\item \code{proc_grp} (num) : identificateur du groupe de traitement.
\item une colonne correspondant à chaque élément de la liste renvoyée par la méthode \ifelse{latex}{\code{osqp::Get Params()}
  }{\code{osqp::GetParams()}} appliquée à un \emph{objet solveur d'OSQP} (objet de classe « osqp_model » tel que renvoyé par
\code{\link[osqp:osqp]{osqp::osqp()}}), ex. :
\itemize{
\item Nombre maximal d'itérations (\code{max_iter});
\item Tolérances d'infaisabilité primale et duale (\code{eps_prim_inf} et \code{eps_dual_inf});
\item Drapeau d'exécution de l'étape de raffinement de la solution (\code{polish});
\item Nombre d'itérations de mise à l'échelle (\code{scaling});
\item etc.
}
\item paramètres supplémentaires spécifiques à \code{\link[=tsbalancing]{tsbalancing()}} :
\itemize{
\item \code{prior_scaling} (logi) : \code{TRUE} si les données du problème ont été mises à l'échelle (en utilisant la moyenne des
valeurs libres (non contraignantes) du problème comme facteur d'échelle) avant la résolution avec OSQP, \code{FALSE} sinon.
\item \code{require_polished} (logi) : \code{TRUE} si une solution \emph{raffinée} d'OSQP (\ifelse{latex}{
    \code{osqp_sol_info_df $status_polish = 1}}{\code{osqp_sol_info_df$status_polish = 1}}) était nécessaire pour cette
étape afin de terminer la séquence de résolution, \code{FALSE} sinon. Voir la \code{vignette("osqp-settings-sequence-dataframe")}
pour plus de détails sur la séquence de résolution utilisée par \code{\link[=tsbalancing]{tsbalancing()}}.
}
}

La colonne \code{proc_grp} constitue une \emph{clé unique} (enregistrements distincts) pour le \emph{data frame}. Visitez le site
\url{https://osqp.org/docs/interfaces/solver_settings.html} pour tous les paramètres d'OSQP disponibles. Les problèmes
(groupes de traitement) pour lesquels la solution initiale a été renvoyée (\code{proc_grp_df$sol_type = "initial"}) ne sont
pas inclus dans ce \emph{data frame}.
\item \strong{osqp_sol_info_df} : \emph{data frame} d'informations sur les solutions OSQP. Il contient un enregistrement (une rangée)
pour chaque problème (groupe de traitement) résolu avec OSQP (\code{proc_grp_df$sol_type = "osqp"}), avec les colonnes suivantes :
\itemize{
\item \code{proc_grp} (num) : identificateur du groupe de traitement.
\item une colonne correspondant à chaque élément de la liste \code{info} d'un \emph{objet solveur d'OSQP} (objet de classe
« osqp_model » tel que renvoyé par \code{\link[osqp:osqp]{osqp::osqp()}}), ex. :
\itemize{
\item Statut de la solution (\code{status} et \code{status_val}) ;
\item Statut de raffinement de la solution (\code{status_polish}) ;
\item Nombre d'itérations (\code{iter}) ;
\item Valeur de la fonction objectif (\code{obj_val}) ;
\item Résidus primal et dual (\code{pri_res} et \code{dua_res}) ;
\item Temps de résolution (\code{solve_time}) ;
\item etc.
}
\item informations supplémentaires spécifiques à \code{\link[=tsbalancing]{tsbalancing()}} :
\itemize{
\item \code{prior_scaling_factor} (num) : valeur du facteur d'échelle lorsque \ifelse{latex}{\code{osqp_settings_df 
    $prior_scaling = TRUE}}{\code{osqp_settings_df$prior_scaling = TRUE}} (\code{prior_scaling_factor = 1.0} sinon).
\item \code{obj_val_ori_prob} (num) : valeur de la fonction objectif du problème d'équilibrage original, qui est la valeur
de la fonction objectif d'OSQP (\code{obj_val}) sur l'échelle originale (lorsque \code{osqp_settings_df$prior_scaling = TRUE})
plus le terme constant de la fonction objectif du problème d'équilibrage original, c.-à-d., \code{obj_val_ori_prob = obj_val 
    * prior_scaling_factor + <terme constant>}, où \verb{<terme constant>} correspond à \eqn{\mathbf{y}^{\mathrm{T}} W \mathbf{y}}{
    y' W y}. Voir la section \strong{Détails} pour la définition du vecteur \eqn{\mathbf{y}}{y}, de la matrice \eqn{W} et, plus
généralement, de l'expression complète de la fonction objectif du problème d'équilibrage.
}
}

La colonne \code{proc_grp} constitue une \emph{clé unique} (enregistrements distincts) pour le \emph{data frame}. Visitez
\url{https://osqp.org} pour plus d'informations sur OSQP. Les problèmes (groupes de traitement) pour lesquels la solution
initiale a été renvoyée (\code{proc_grp_df$sol_type = "initial"}) ne sont pas inclus dans ce \emph{data frame}.
}

Notez que les objets de type « data.frame » renvoyés par la fonction peuvent être explicitement convertis en d'autres types
d'objets avec la fonction \verb{as*()} appropriée (ex., \code{tibble::as_tibble()} convertirait n'importe lequel d'entre eux en tibble).
}
\description{
\emph{Réplication de la macro \emph{\strong{GSeriesTSBalancing}} de G-Séries 2.0 en SAS\eqn{^\circledR}{®}. Voir la documentation
de G-Séries 2.0 pour plus de détails (Statistique Canada 2016).}

Cette fonction équilibre (réconcilie) un système de séries chronologiques selon un ensemble de contraintes linéaires.
La solution d'équilibrage (« \emph{balancing} ») est obtenue en résolvant un ou plusieurs problèmes de minimisation quadratique
(voir la section \strong{Détails}) avec le solveur OSQP (Stellato et al. 2020). Étant donné la faisabilité du (des) problème(s)
d'équilibrage, les données des séries chronologiques résultantes respectent les contraintes spécifiées pour chaque période.
Des contraintes linéaires d'égalité et d'inégalité sont permises. Optionnellement, la préservation des totaux temporels peut
également être spécifiée.
}
\details{
Cette fonction résout un problème d'équilibrage par groupe de traitement (voir la section \strong{Groupes de traitement} pour
plus de détails). Chacun de ces problèmes d'équilibrage est un problème de minimisation quadratique de la forme suivante :
\deqn{\displaystyle 
\begin{aligned}
& \underset{\mathbf{x}}{\text{minimiser}} 
& & \mathbf{\left( y - x \right)}^{\mathrm{T}} W \mathbf{\left( y - x \right)} \\
& \text{sous contrainte(s)} 
& & \mathbf{l} \le A \mathbf{x} \le \mathbf{u}
\end{aligned}
}{min(x) (y - x)' W (y - x), sous contrainte(s) l <= Ax <= u}
où
\itemize{
\item \eqn{\mathbf{y}}{y} est le vecteur des valeurs initiales du problème, c.-à-d., les valeurs de période initiales et, le cas
échéant, les totaux temporels initiaux des séries chronologiques;
\item \eqn{\mathbf{x}}{x} est la version finale (réconciliée) du vecteur \eqn{\mathbf{y}}{y};
\item la matrice \eqn{W = \mathrm{diag} \left( \mathbf{w} \right)}{W = diag(w)} avec les éléments du vecteur \eqn{\mathbf{w}}{w}
définis comme \eqn{w_i = \left\{
    \begin{array}{cl}
      0 & \text{if } |c_i y_i| = 0 \\
      \frac{1}{|c_i y_i|} & \text{sinon}
    \end{array} \right.
    }{w_i = 0 if |c_i y_i| = 0, w_i = 1/|c_i y_i| sinon},
où \eqn{c_i} est coefficient d'altérabilité de la valeur du problème \eqn{y_i} et où les cas correspondant à \eqn{|c_i 
    y_i| = 0} sont des valeurs fixes (valeurs de période ou totaux temporels contraignants);
\item la matrice \eqn{A} et les vecteurs \eqn{\mathbf{l}}{l} et \eqn{\mathbf{u}}{u} définissent les \emph{contraintes d'équilibrage},
les \emph{contraintes implicites d'agrégation temporelle} (le cas échéant), les \emph{bornes (inférieures et supérieures) des
valeurs de période} et \emph{les contraintes \eqn{x_i = y_i} pour les valeurs \eqn{y_i} fixes} \eqn{\left( \left| c_i y_i \right| 
= 0 \right)}{(|c_i y_i| = 0)}.
}

En pratique, la fonction objectif du problème résolu par OSQP exclut le terme constant \eqn{\mathbf{y}^{\mathrm{T}} W 
\mathbf{y}}{y' W y}, correspondant alors à \eqn{\mathbf{x}^{\mathrm{T}} W \mathbf{x} - 2 \left( \mathbf{w} \mathbf{y} 
\right)^{\mathrm{T}} \mathbf{x}}{x' W x - 2 (w y)' x}, et les valeurs \eqn{y_i} fixes \eqn{\left( \left| c_i y_i \right| 
= 0 \right)}{(|c_i y_i| = 0)} sont exclues du problème, en ajustant les contraintes en conséquence, c.-à-d. :
\itemize{
\item les lignes correspondant aux \emph{contraintes \eqn{x_i = y_i} pour les valeurs \eqn{y_i} fixes} sont supprimées de \eqn{A},
\eqn{\mathbf{l}}{l} et \eqn{\mathbf{u}}{u};
\item les colonnes correspondant aux valeurs \eqn{y_i} fixes sont supprimées de \eqn{A} tout en ajustant de manière appropriée
\eqn{\mathbf{l}}{l} et \eqn{\mathbf{u}}{u}.
}
\subsection{Coefficients d'altérabilité}{

Les coefficients d'altérabilité sont des nombres non négatifs qui modifient le coût relatif de la modification d'une valeur
initiale du problème. En modifiant la fonction objectif à minimiser, ils permettent de générer un large éventail de solutions.
Puisqu'ils apparaissent dans le dénominateur de la fonction objectif (matrice \eqn{W}), plus le coefficient d'altérabilité
est élevé, moins il est coûteux de modifier une valeur du problème (valeur de période ou total temporel) et, inversement,
plus le coefficient d'altérabilité est petit, plus il devient coûteux de le faire. Il en résulte que les valeurs du problème
ayant des coefficients d'altérabilité plus élevés changent proportionnellement plus que celles ayant des coefficients
d'altérabilité plus petits. Un coefficient d'altérabilité de \eqn{0.0} définit une valeur de problème fixe (contraignante),
tandis qu'un coefficient d'altérabilité supérieur à \eqn{0.0} définit une valeur libre (non contraignante). Les coefficients
d'altérabilité par défaut sont \eqn{0.0} pour les totaux temporels (argument \code{alter_temporal}) et \eqn{1.0} pour les valeurs
de période (arguments \code{alter_pos}, \code{alter_neg}, \code{alter_mix}). Dans le cas courant des problèmes de ratissage (« \emph{raking} »)
de tables d'agrégation, les valeurs de période des totaux de marge (séries chronologiques avec un coefficient de \eqn{-1}
dans les contraintes d'équilibrage) sont généralement contraignantes (spécifié avec \code{alter_neg = 0}) tandis que les valeurs
de période des séries composantes (séries chronologiques avec un coefficient \eqn{1} dans les contraintes d'équilibrage) sont
généralement non contraignantes (spécifié avec \code{alter_pos > 0}, ex., \code{alter_pos = 1}). Des valeurs de problème \emph{presque
contraignantes} (ex., pour les totaux de marge ou les totaux temporels) peuvent être obtenues en pratique en spécifiant de
très petits (presque \eqn{0.0}) coefficents d'altérabilité par rapport à ceux des autres valeurs (non contraignantes) du
problème.

\strong{La préservation des totaux temporels} fait référence au fait que les totaux temporels, le cas échéant, sont
généralement conservés « aussi près que possible » de leur valeur initiale. Une \emph{préservation pure} est obtenue par
défaut avec des totaux temporels contraignants, tandis que le changement est minimisé avec des totaux temporels non
contraignants (conformément à l'ensemble de coefficients d'altérabilité utilisés).
}

\subsection{Validation et dépannage}{

Les problèmes d'équilibrage fructueux (problèmes avec une solution valide) ont \code{sol_status_val > 0} ou, de manière
équivalente, \code{n_unmet_con = 0} ou \code{max_discr <= validation_tol} dans le \emph{data frame} de sortie \strong{proc_grp_df}.
Le dépannage des problèmes d'équilibrage infructueux n'est pas nécessairement simple. Voici quelques suggestions :
\itemize{
\item Examinez les contraintes qui ont échoué (\code{unmet_flag = TRUE} ou, de manière équivalente, \code{discr_out > validation_tol}
dans le \emph{data frame} de sortie \strong{prob_conf_df}) pour s'assurer qu'elles ne causent pas un espace de solution vide
(problème infaisable).
\item Modifier la séquence de résolution d'OSQP. Par exemple, essayez :
\enumerate{
\item l' argument \code{full_sequence = TRUE}
\item l' argument \code{osqp_settings_df = alternate_osqp_sequence}
\item les arguments \code{osqp_settings_df = alternate_osqp_sequence} et \code{full_sequence = TRUE}
}

Voir la \code{vignette("osqp-settings-sequence-dataframe")} pour plus de détails sur ce sujet.
\item Augmenter (revoir) la valeur de \code{validation_tol}. Bien que cela puisse ressembler à de la \emph{tricherie}, la valeur par
défaut de \code{validation_tol} (\eqn{1 \times 10^{-3}}) peut en fait être trop petite pour les problèmes d'équilibrage qui
impliquent de très grandes valeurs (ex., en milliards) ou, inversement, trop grande avec des valeurs de problème très
petites (ex., \eqn{< 1.0}). Multiplier l'échelle moyenne des données du problème par la \emph{tolérance de la machine}
(\code{.Machine$double.eps}) donne une approximation de la taille moyenne des écarts que \code{\link[=tsbalancing]{tsbalancing()}} devrait être capable
de détecter (distinguer de \eqn{0}) et devrait probablement constituer une \strong{limite inférieure absolue} pour l'argument
\code{validation_tol}. En pratique, une valeur raisonnable de \code{validation_tol} devrait probablement être de \eqn{1 
\times 10^3} à \eqn{1 \times 10^6} fois plus grande que cette \emph{limite inférieure}.
\item S'attaquer aux contraintes redondantes. Les problèmes de ratissage (« \emph{raking} ») de tables d'agrégation
multidimensionnelles sont surspécifiés (ils impliquent des contraintes redondantes) lorsque tous les totaux de toutes
les dimensions du \emph{cube de données} sont contraignants (fixes) et qu'une contrainte est définie pour chacun d'entre eux.
La redondance se produit également pour les contraintes implicites d'agrégation temporelle dans les tables d'agrégation
unidimensionnelles ou multidimensionnelles avec des totaux temporels contraignants (fixes). La surspécification n'est
généralement pas un problème pour \code{\link[=tsbalancing]{tsbalancing()}} si les données d'entrée ne sont pas contradictoires en ce qui concerne
les contraintes redondantes, c'est-à-dire, s'il n'y a pas d'incohérences (d'écarts) associées aux contraintes redondantes
dans les données d'entrée ou si elles sont \emph{négligeables} (raisonnablement faibles par rapport à l'échelle des données
du problème). Dans le cas contraire, cela peut conduire à des problèmes d'équilibrage infructueux \code{\link[=tsbalancing]{tsbalancing()}}. Les
solutions possibles sont alors les suivantes :
\enumerate{
\item Résoudre (ou réduire) les écarts associés aux contraintes redondantes dans les données d'entrée.
\item Sélectionner un total de marge dans chaque dimension, sauf une, du cube de données et supprimer du problème les
contraintes d'équilibrage correspondantes. \emph{Cela ne peut pas être fait pour les contraintes implicites d'agrégation
temporelle.}
\item Sélectionnez un total de marge dans chaque dimension, sauf une, du cube de données et rendez-les non contraignantes
(coefficient d'altérabilité de, disons, \eqn{1.0}).
\item Faire la même chose que (3) pour les totaux temporels d'une des séries composantes de l'intérieur du cube (les
rendre non contraignants).
\item Rendre tous les totaux de marge de chaque dimension, sauf une, du cube de données \emph{presque contraignants}, c.-à-d.,
spécifier de très petits coefficients d'altérabilité (disons \eqn{1 \times 10^{-6}}) par rapport à ceux des séries
composantes de l'intérieur du cube.
\item Faire la même chose que (5) pour les totaux temporels de toutes les séries composantes de l'intérieur du cube
(coefficients d'altérabilité très petits, par exemple, avec l'argument \code{alter_temporal}).
\item Utilisez \code{\link[=tsraking]{tsraking()}} (le cas échéant), qui gère ces incohérences en utilisant l'inverse de Moore-Penrose
(distribution uniforme à travers tous les totaux contraignants).
}

Les solutions (2) à (7) ci-dessus ne doivent être envisagées que si les écarts associés aux contraintes redondantes
dans les données d'entrée sont \emph{raisonnablement faibles} car ils seraient distribués parmi les totaux omis ou non
contraignants avec \code{\link[=tsbalancing]{tsbalancing()}} et tous les totaux contraignants avec \code{\link[=tsraking]{tsraking()}}. Sinon, il faut d'abord étudier
la solution (1) ci-dessus.
\item Assouplir (relaxer) les bornes des contraintes du problème, par exemple :
\itemize{
\item avec l'argument \code{tolV} pour les contraintes d'équilibrage;
\item avec les arguments \code{tolV_temporal} et \code{tolP_temporal} pour les contraintes implicites d'agrégation temporelle;
\item avec les arguments \code{lower_bound} et \code{upper_bound}.
}
}
}
}
\section{Groupes de traitement}{
L'ensemble des périodes d'un problème de réconciliation (ratissage ou équilibrage) donné est appelé \emph{groupe de
traitement} et correspond soit :
\itemize{
\item à une \strong{période unique} lors d'un traitement période par période ou, lorsque les totaux temporels sont préservés,
pour les périodes individuelles d'un groupe temporel incomplet (ex., une année incomplète)
\item ou à l'\strong{ensemble des périodes d'un groupe temporel complet} (ex., une année complète) lorsque les totaux temporels
sont préservés.
}

Le nombre total de groupes de traitement (nombre total de problèmes de réconciliation) dépend de l'ensemble de périodes
des séries chronologiques d'entrée (objet de type série chronologique spécifié avec l'argument \code{in_ts}) et de la valeur
des arguments \code{temporal_grp_periodicity} et \code{temporal_grp_start}.

Les scénarios courants incluent \code{temporal_grp_periodicity = 1} (par défaut) pour un traitement période par période sans
préservation des totaux temporels et \ifelse{latex}{\code{temporal_grp_periodicity = freq uency(in_ts)}}{
\code{temporal_grp_periodicity = frequency(in_ts)}} pour la préservation des totaux annuels (années civiles par défaut).
L'argument \code{temporal_grp_start} permet de spécifier d'autres types d'années (\emph{non civile}). Par exemple, des années
financières commençant en avril correspondent à \code{temporal_grp_start = 4} avec des données mensuelles et à
\code{temporal_grp_start = 2} avec des données trimestrielles. La préservation des totaux trimestriels avec des données
mensuelles correspondrait à \code{temporal_grp_periodicity = 3}.

Par défaut, les groupes temporels convrant plus d'une année (c.-à-d., correspondant à \ifelse{latex}{\code{
temporal_grp _periodicity > frequency(in_ts)}}{\code{temporal_grp_periodicity > frequency(in_ts)}}) débutent avec une année
qui est un multiple de \ifelse{latex}{\code{ceiling( temporal_grp_periodicity / frequency(in_ts))}}{\code{
ceiling(temporal_grp_periodicity / frequency(in_ts))}}. Par exemple, les groupes bisannuels correspondant à
\code{temporal_grp_periodicity = 2 * frequency(in_ts)} débutent avec une \emph{année paire} par défaut. Ce comportement peut être
modifié avec l'argument \code{temporal_grp_start}. Par exemple, la préservation des totaux bisannuels débutant avec une \emph{année
impaire} au lieu d'une \emph{année paire} (par défaut) correspond à \code{temporal_grp_start = frequency(in_ts) + 1} (avec
\ifelse{latex}{\code{temporal_grp _periodicity = 2 * frequency(in_ts)}}{\code{temporal_grp_periodicity = 2 * frequency(in_ts)}}).

Voir les \strong{Exemples} de \code{\link[=gs.build_proc_grps]{gs.build_proc_grps()}} pour des scénarios courants de groupes de traitements.
}

\section{Comparaison de \code{\link[=tsraking]{tsraking()}} et \code{\link[=tsbalancing]{tsbalancing()}}}{
\itemize{
\item \code{\link[=tsraking]{tsraking()}} est limitée aux problèmes de ratissage (« \emph{raking} ») de tables d'agrégation unidimensionnelles et
bidimensionnelles (avec préservation des totaux temporels si nécessaire) alors que \code{\link[=tsbalancing]{tsbalancing()}} traite des problèmes
d'équilibrage plus généraux (ex., des problèmes de ratissage de plus grande dimension, solutions non négatives,
contraintes linéaires générales d'égalité et d'inégalité par opposition à des règles d'agrégation uniquement, etc.)
\item \code{\link[=tsraking]{tsraking()}} renvoie la solution des moindres carrés généralisés du modèle de ratissage basé sur la régression de
Dagum et Cholette (Dagum et Cholette 2006) tandis que \code{\link[=tsbalancing]{tsbalancing()}} résout le problème de minimisation quadratique
correspondant à l'aide d'un solveur numérique. Dans la plupart des cas, la \emph{convergence vers le minimum} est atteinte
et la solution de \code{\link[=tsbalancing]{tsbalancing()}} correspond à la solution (exacte) des moindres carrés de \code{\link[=tsraking]{tsraking()}}. Cela peut ne
pas être le cas, cependant, si la convergence n'a pas pu être atteinte après un nombre raisonnable d'itérations. Cela
dit, ce n'est qu'en de très rares occasions que la solution de \code{\link[=tsbalancing]{tsbalancing()}} différera \emph{significativement} de celle
de \code{\link[=tsraking]{tsraking()}}.
\item \code{\link[=tsbalancing]{tsbalancing()}} est généralement plus rapide que \code{\link[=tsraking]{tsraking()}}, en particulier pour les gros problèmes de ratissage,
mais est généralement plus sensible à la présence de (petites) incohérences dans les données d'entrée associées aux
contraintes redondantes des problèmes de ratissage \emph{entièrement spécifiés} (ou surspécifiés). \code{\link[=tsraking]{tsraking()}} gère ces
incohérences en utilisant l'inverse de Moore-Penrose (distribution uniforme à travers tous les totaux contraignants).
\item \code{\link[=tsbalancing]{tsbalancing()}} permet de spécifier des problèmes épars (clairsemés) sous leur forme réduite. Ce n'est pas le cas de
\code{\link[=tsraking]{tsraking()}} où les règles d'agrégation doivent toujours être entièrement spécifiées étant donné qu'un \emph{cube de données
complet}, sans données manquantes, est attendu en entrée (chaque série composante de l'\emph{intérieur du cube} doit
contribuer à toutes les dimensions du cube, c.-à-d., à chaque série totale des \emph{faces extérieures du cube}).
\item Les deux outils traitent différemment les valeurs négatives dans les données d'entrée par défaut. Alors que les
solutions des problèmes de ratissage obtenues avec \code{\link[=tsbalancing]{tsbalancing()}} et \code{\link[=tsraking]{tsraking()}} sont identiques lorsque tous les
points de données d'entrée sont positifs, elles seront différentes si certains points de données sont négatifs (à
moins que l'argument \code{Vmat_option = 2} ne soit spécifié avec \code{\link[=tsraking]{tsraking()}}).
\item Alors que \code{\link[=tsbalancing]{tsbalancing()}} et \code{\link[=tsraking]{tsraking()}} permettent toutes les deux de préserver les totaux temporels, la gestion
du temps n'est pas incorporée dans \code{\link[=tsraking]{tsraking()}}. Par exemple, la construction des groupes de traitement (ensembles de
périodes de chaque problème de ratissage) est laissée à l'utilisateur avec \code{\link[=tsraking]{tsraking()}} et des appels séparés doivent
être soumis pour chaque groupe de traitement (chaque problème de ratissage). De là l'utilité de la fonction
d'assistance \code{\link[=tsraking_driver]{tsraking_driver()}} pour \code{\link[=tsraking]{tsraking()}}.
\item \code{\link[=tsbalancing]{tsbalancing()}} renvoie le même ensemble de séries que l'objet d'entrée de type série chronologique (argument
\code{in_ts}) alors que \code{\link[=tsraking]{tsraking()}} renvoie l'ensemble des séries impliquées dans le problème de ratissage plus celles
spécifiées avec l'argument \code{id} (qui pourrait correspondre à un sous-ensemble des séries d'entrée).
}
}

\examples{
###########
# Exemple 1 : Dans ce premier exemple, l'objectif est d'équilibrer un tableau comptable simple 
#             (`Profits = Revenus - Depenses`), pour 5 trimestres, sans modifier les `Profits` 
#             et où `Revenus >= 0` et `Depenses >= 0`.

# Spécifications du problème
mes_specs1 <- data.frame(type = c("EQ", rep(NA, 3), 
                                  "alter", NA, 
                                  "lowerBd", NA, NA),
                         col = c(NA, "Revenus", "Depenses", "Profits", 
                                 NA, "Profits", 
                                 NA, "Revenus", "Depenses"),
                         row = c(rep("Règle comptable", 4), 
                                 rep("Coefficient d'altérabilité", 2), 
                                 rep("Borne inférieure", 3)),
                         coef = c(NA, 1, -1, -1,
                                  NA, 0,
                                  NA, 0, 0))
mes_specs1

# Données du problème
mes_series1 <- ts(matrix(c( 15,  10,  10,
                             4,   8,  -1,
                           250, 250,   5,
                             8,  12,   0,
                             0,  45, -55),
                         ncol = 3,
                         byrow = TRUE,
                         dimnames = list(NULL, c("Revenus", "Depenses", "Profits"))),
                  start = c(2022, 1),
                  frequency = 4)

# Réconcilier les données
res_equi1 <- tsbalancing(in_ts = mes_series1,
                         problem_specs_df = mes_specs1,
                         display_level = 3)

# Données initiales
mes_series1

# Données réconciliées
res_equi1$out_ts

# Vérifier la présence de solutions invalides
any(res_equi1$proc_grp_df$sol_status_val < 0)

# Afficher les écarts maximaux des contraintes en sortie
res_equi1$proc_grp_df[, c("proc_grp_label", "max_discr")]


# La solution renvoyée par `tsbalancing()` correspond à des changements proportionnels 
# égaux (au prorata) et est associée aux coefficients d'altérabilité par défaut de 1. 
# Des changements absolus égaux peuvent être obtenus en spécifiant des coefficients 
# d'altérabilité égaux à l'inverse des valeurs initiales. 
# 
# Faisons cela pour le groupe de traitement 2022T2 (`timeVal = 2022.25`), avec le niveau 
# d'information affiché par défaut (`display_level = 1`).

mes_specs1b <- rbind(cbind(mes_specs1, 
                          data.frame(timeVal = rep(NA_real_, nrow(mes_specs1)))),
                    data.frame(type = rep(NA, 2),
                               col = c("Revenus", "Depenses"),
                               row = rep("Coefficient d'altérabilité", 2),
                               coef = c(0.25, 0.125),
                               timeVal = rep(2022.25, 2)))
mes_specs1b

res_equi1b <- tsbalancing(in_ts = mes_series1,
                          problem_specs_df = mes_specs1b)

# Afficher les valeurs initiales de 2022T2 et les deux solutions
cbind(data.frame(Statut = c("initial", "prorata", "changement égal")),
      rbind(as.data.frame(mes_series1[2, , drop = FALSE]), 
            as.data.frame(res_equi1$out_ts[2, , drop = FALSE]),
            as.data.frame(res_equi1b$out_ts[2, , drop = FALSE])),
      data.frame(Ecart_comptable = c(mes_series1[2, 1] - mes_series1[2, 2] - 
                                       mes_series1[2, 3],
                                     res_equi1$out_ts[2, 1] - 
                                       res_equi1$out_ts[2, 2] - 
                                       res_equi1$out_ts[2, 3],
                                     res_equi1b$out_ts[2, 1] - 
                                       res_equi1b$out_ts[2, 2] - 
                                       res_equi1b$out_ts[2, 3]),
                 ChgRel_Rev = c(NA, 
                                res_equi1$out_ts[2, 1] / mes_series1[2, 1] - 1,
                                res_equi1b$out_ts[2, 1] / mes_series1[2, 1] - 1),
                 ChgRel_Dep = c(NA, 
                                res_equi1$out_ts[2, 2] / mes_series1[2, 2] - 1,
                                res_equi1b$out_ts[2, 2] / mes_series1[2, 2] - 1),
                 ChgAbs_Rev = c(NA, 
                                res_equi1$out_ts[2, 1] - mes_series1[2, 1],
                                res_equi1b$out_ts[2, 1] - mes_series1[2, 1]),
                 ChgAbs_Dep = c(NA, 
                                res_equi1$out_ts[2, 2] - mes_series1[2, 2],
                                res_equi1b$out_ts[2, 2] - mes_series1[2, 2])))


###########
# Exemple 2 : Dans ce deuxième exemple, nous considérons les données simulées des  
#             ventes trimestrielles de véhicules par région (Ouest, Centre et Est), 
#             ainsi qu'un total national pour les trois régions, et par type de véhicules 
#             (voitures, camions et un total qui peut inclure d'autres types de véhicules). 
#             Les données correspondent à des données directement désaisonnalisées qui 
#             ont été étalonnées aux totaux annuels des séries originales (non 
#             désaisonnalisées) correspondantes dans le cadre du processus de 
#             désaisonnalisation (par exemple, avec le « spec » FORCE du logiciel 
#             X-13ARIMA-SEATS). 
#
#             L'objectif est de réconcilier les ventes régionales avec les ventes 
#             nationales sans modifier ces dernières, tout en veillant à ce que la somme 
#             des ventes de voitures et de camions ne dépasse pas 95\% des ventes de tous 
#             les types de véhicules au cours d'un trimestre donné. À titre d'exemple, 
#             nous supposons que les ventes de camions dans la région Centre pour le 2e 
#             trimestre 2022 ne peuvent pas être modifiées.

# Spécifications du problème
mes_specs2 <- data.frame(
  
  type = c("EQ", rep(NA, 4),
           "EQ", rep(NA, 4),
           "EQ", rep(NA, 4),
           "LE", rep(NA, 3),
           "LE", rep(NA, 3),
           "LE", rep(NA, 3),
           "alter", rep(NA, 4)),
  
  col = c(NA, "Ouest_Tous", "Centre_Tous", "Est_Tous", "National_Tous", 
          NA, "Ouest_Autos", "Centre_Autos", "Est_Autos", "National_Autos", 
          NA, "Ouest_Camions", "Centre_Camions", "Est_Camions", "National_Camions", 
          NA, "Ouest_Autos", "Ouest_Camions", "Ouest_Tous", 
          NA, "Centre_Autos", "Centre_Camions", "Centre_Tous", 
          NA, "Est_Autos", "Est_Camions", "Est_Tous",
          NA, "National_Tous", "National_Autos", "National_Camions", "Centre_Camions"),
  
  row = c(rep("Total national - Tous les véhicules", 5),
          rep("Total national - Autos", 5),
          rep("Total national - Camions", 5),
          rep("Somme région Ouest", 4),
          rep("Somme région Centre", 4),
          rep("Somme région Est", 4),
          rep("Coefficient d'altérabilité", 5)),
  
  coef = c(NA, 1, 1, 1, -1,
           NA, 1, 1, 1, -1,
           NA, 1, 1, 1, -1,
           NA, 1, 1, -.95,
           NA, 1, 1, -.95,
           NA, 1, 1, -.95,
           NA, 0, 0, 0, 0),
  
  time_val = c(rep(NA, 31), 2022.25))

# Début et fin du « data frame » des spécifications
head(mes_specs2, n = 10)
tail(mes_specs2)

# Données du problème
mes_series2 <- ts(
  matrix(c(43, 49, 47, 136, 20, 18, 12, 53, 20, 22, 26, 61,
           40, 45, 42, 114, 16, 16, 19, 44, 21, 26, 21, 59,
           35, 47, 40, 133, 14, 15, 16, 50, 19, 25, 19, 71,
           44, 44, 45, 138, 19, 20, 14, 52, 21, 18, 27, 74,
           46, 48, 55, 135, 16, 15, 19, 51, 27, 25, 28, 54),
         ncol = 12,
         byrow = TRUE,
         dimnames = list(NULL, 
                         c("Ouest_Tous", "Centre_Tous", "Est_Tous", 
                           "National_Tous", "Ouest_Autos", "Centre_Autos", 
                           "Est_Autos", "National_Autos", "Ouest_Camions", 
                           "Centre_Camions", "Est_Camions", "National_Camions"))),
  start = c(2022, 1),
  frequency = 4)

# Réconcilier sans afficher l'en-tête de la fonction et imposer des données non négatives
res_equi2 <- tsbalancing(
  in_ts                    = mes_series2,
  problem_specs_df         = mes_specs2,
  temporal_grp_periodicity = frequency(mes_series2),
  lower_bound              = 0,
  quiet                    = TRUE)

# Données initiales
mes_series2

# Données réconciliées
res_equi2$out_ts

# Vérifier la présence de solutions invalides
any(res_equi2$proc_grp_df$sol_status_val < 0)

# Afficher les écarts maximaux des contraintes en sortie
res_equi2$proc_grp_df[, c("proc_grp_label", "max_discr")]


###########
# Exemple 3 : Reproduire le 2ème exemple de `tsraking_driver()` avec `tsbalancing()` 
#             (ratissage à 1 dimension avec préservation des totaux annuels).

# Métadonnées de `tsraking()`
mes_meta3 <- data.frame(series = c("autos_alb", "autos_sask", "autos_man"),
                        total1 = rep("autos_tot", 3))
mes_meta3

# Spécifications du problème de `tsbalancing()`
mes_specs3 <- rkMeta_to_blSpecs(mes_meta3)
mes_specs3

# Données du problème
mes_series3 <- ts(matrix(c(14, 18, 14, 58,
                           17, 14, 16, 44,
                           14, 19, 18, 58,
                           20, 18, 12, 53,
                           16, 16, 19, 44,
                           14, 15, 16, 50,
                           19, 20, 14, 52,
                           16, 15, 19, 51),
                         ncol = 4,
                         byrow = TRUE,
                         dimnames = list(NULL, c("autos_alb", "autos_sask",
                                                 "autos_man", "autos_tot"))),
                  start = c(2019, 2),
                  frequency = 4)

# Réconcilier les données avec `tsraking()` (via `tsraking_driver()`)
res_ratis3 <- tsraking_driver(in_ts = mes_series3,
                              metadata_df = mes_meta3,
                              temporal_grp_periodicity = frequency(mes_series3),
                              quiet = TRUE)

# Réconcilier les données avec `tsbalancing()`
res_equi3 <- tsbalancing(in_ts = mes_series3,
                         problem_specs_df = mes_specs3,
                         temporal_grp_periodicity = frequency(mes_series3),
                         quiet = TRUE)

# Données initiales
mes_series3

# Les deux ensembles de données réconciliées
res_ratis3
res_equi3$out_ts

# Vérifier la présence de solutions de `tsbalancing()` invalides
any(res_equi3$proc_grp_df$sol_status_val < 0)

# Afficher les écarts maximaux des contraintes en sortie dans les solutions de `tsbalancing()`
res_equi3$proc_grp_df[, c("proc_grp_label", "max_discr")]

# Confirmer que les deux solutions (`tsraking() et `tsbalancing()`) sont les mêmes
all.equal(res_ratis3, res_equi3$out_ts)
}
\references{
Dagum, E. B. et P. Cholette (2006). \strong{Benchmarking, Temporal Distribution and Reconciliation Methods
of Time Series}. Springer-Verlag, New York, Lecture Notes in Statistics, Vol. 186.

Ferland, M., S. Fortier et J. Bérubé (2016). « A Mathematical Optimization Approach to Balancing Time Series:
Statistics Canada’s GSeriesTSBalancing ». Dans \strong{JSM Proceedings, Business and Economic Statistics Section}. Alexandria,
VA: American Statistical Association. 2292-2306.

Ferland, M. (2018). « Time Series Balancing Quadratic Problem — Hessian matrix and vector of linear objective
function coefficients ». \strong{Document interne}. Statistique Canada, Ottawa, Canada.

Quenneville, B. et S. Fortier (2012). « Restoring Accounting Constraints in Time Series – Methods and
Software for a Statistical Agency ». \strong{Economic Time Series: Modeling and Seasonality}. Chapman & Hall, New York.

SAS Institute Inc. (2015). « The LP Procedure Sparse Data Input Format ». \strong{SAS/OR\eqn{^\circledR}{®} 14.1 User's
Guide: Mathematical Programming Legacy Procedures}.
\url{https://support.sas.com/documentation/cdl/en/ormplpug/68158/HTML/default/viewer.htm#ormplpug_lp_details03.htm}

Statistique Canada (2016). « La macro \emph{\strong{GSeriesTSBalancing}} ». \strong{Guide de l'utilisateur de G-Séries 2.0}.
Statistique Canada, Ottawa, Canada.

Statistique Canada (2018). \strong{Théorie et application de la réconciliation (Code du cours 0437)}.
Statistique Canada, Ottawa, Canada.

Stellato, B., G. Banjac, P. Goulart et al. (2020). « OSQP: an operator splitting solver for quadratic programs ».
\strong{Math. Prog. Comp. 12}, 637–672 (2020). \url{https://doi.org/10.1007/s12532-020-00179-2}
}
\seealso{
\code{\link[=tsraking]{tsraking()}} \code{\link[=tsraking_driver]{tsraking_driver()}} \code{\link[=rkMeta_to_blSpecs]{rkMeta_to_blSpecs()}} \code{\link[=gs.build_proc_grps]{gs.build_proc_grps()}} \code{\link[=build_balancing_problem]{build_balancing_problem()}} \link{aliases}
}
