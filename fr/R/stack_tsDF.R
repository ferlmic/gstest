#' Empiler des données de séries chronologiques 
#'
#'
#' @description
#' Convertir un *data frame* de séries chronologiques multivariées (voir [ts_to_tsDF()]) pour les fonctions d'étalonnage 
#' ([benchmarking()] et [stock_benchmarking()]) en un *data frame* empilé (long) avec quatre variables (colonnes) :
#' * une (1) pour le nom de la série
#' * deux (2) pour l'identification du point de données (année et période)
#' * une (1) pour la valeur du point de données
#'
#' Les valeurs de série manquantes (`NA`) ne sont pas incluses par défaut dans le *data frame* empilé renvoyé par 
#' la fonction. Spécifiez l'argument `keep_NA = TRUE` pour les conserver.
#'
#' Cette fonction est utile lorsque l'on souhaite utiliser l'argument `by` (mode de traitement *groupes-BY*) des 
#' fonctions d'étalonnage afin d'étalonner plusieurs séries en un seul appel de fonction.
#'
#'
#' @param ts_df (obligatoire)
#'
#' *Data frame*, ou objet compatible, qui contient les données de séries chronologiques multivariées à empiler.
#'
#' @param ser_cName (optionnel)
#'
#' Chaîne de caractères spécifiant le nom de la variable (colonne) du *data frame* empilé de sortie qui contiendra 
#' les nom des séries (nom des variables des séries dans le *data frame* de séries chronologiques multivariées d'entrée). 
#' Cette variable peut ensuite être utilisée comme variable de groupes-BY (argument `by`) avec les fonctions d'étalonnage.
#'
#' **La valeur par défaut** est `ser_cName = "series"`.
#'
#' @param yr_cName,per_cName (optionnel)
#'
#' Chaînes de caractères spécifiant le nom des variables (colonnes) numériques du *data frame* de séries chronologiques 
#' multivariées d'entrée qui identifient l'année et la période (cycle) des points de données. Ces variables sont *transférées* 
#' dans le *data frame* empilé de sortie avec les mêmes noms de variable.
#'
#' **Les valeurs par défaut** sont `yr_cName = "year"` et `per_cName = "period"`.
#'
#' @param val_cName (optionnel)
#'
#' Chaîne de caractères spécifiant le nom de la variable (colonne) du *data frame* empilé de sortie qui contiendra 
#' la valeur des points de données.
#'
#' **La valeur par défaut** est `val_cName = "value"`.
#'
#' @param keep_NA (optionnel)
#'
#' Argument logique (*logical*) spécifiant si les valeurs de série manquantes (`NA`) du *data frame* de séries 
#' chronologiques multivariées d'entrée doivent être conservées dans le *data frame* empilé de sortie.
#'
#' **La valeur par défaut** est `keep_NA = FALSE`.
#'
#'
#' @returns
#' La fonction renvoie un *data frame* avec quatre variables :
#' * Nom de la série, type caractère (voir l'argument `ser_cName`)
#' * Année du point de données, type numérique (voir argument `yr_cName`)
#' * Période du point de données, type numérique (voir argument `per_cName`)
#' * Valeur du point de données, type numérique (voir argument `val_cName`)
#'
#' Note : la fonction renvoie un objet « data.frame » qui peut être explicitement converti en un autre 
#' type d'objet avec la fonction `as*()` appropriée (ex., `tibble::as_tibble()` le convertirait en tibble).
#'
#'
#' @seealso [unstack_tsDF()] [stack_bmkDF()] [ts_to_tsDF()] [benchmarking()] [stock_benchmarking()]
#'
#'
#' @example misc/function_examples/stack_tsDF-ex.R
#'
#'
#' @export
stack_tsDF <- function(ts_df,
                       ser_cName = "series",
                       yr_cName = "year",
                       per_cName = "period",
                       val_cName = "value",
                       keep_NA = FALSE) {
  
  # Enforce the default R "error" option (`options(error = NULL)`). E.g. this Turns off traceback
  # generated by calls to the stop() function inside internal functions in R Studio.
  ini_error_opt <- getOption("error")
  on.exit(options(error = ini_error_opt))
  options(error = NULL)
  
  # validate object
  if (!is.data.frame(ts_df)) {
    stop("Argument 'ts_df' is not a 'data.frame' object.\n\n", call. = FALSE)
  }
  ts_df <- as.data.frame(ts_df)
  df_cols <- names(ts_df)
  date_cols <- c(yr_cName, per_cName)
  date_args <- c("yr_cName", "per_cName")
  for (ii in seq_along(date_cols)) {
    if (!(date_cols[ii] %in% df_cols)) {
      stop("The input data frame does not contain column \"", date_cols[ii], "\" (argument '",
           date_args[ii], "').\n\n", call. = FALSE)
    }
  }
  
  ser_list <- setdiff(names(ts_df), date_cols)
  out_df <- data.frame(col1 = character(),
                       col2 = integer(),
                       col3 = integer(),
                       col4 = double(),
                       stringsAsFactors = FALSE)
  for (ser in ser_list) {
    if (gs.validate_arg_logi(keep_NA)) {
      tmp_df <- ts_df[c(date_cols, ser)]
    } else {
      tmp_df <- ts_df[!is.na(ts_df[ser]), c(date_cols, ser)]
    }
    out_df <- rbind(out_df, data.frame(col1 = ser,
                                       col2 = as.integer(tmp_df[[yr_cName]]),
                                       col3 = as.integer(tmp_df[[per_cName]]),
                                       col4 = as.numeric(tmp_df[[ser]]),
                                       stringsAsFactors = FALSE))
  }
  
  # Set the column names and reset the now names (numbers)
  names(out_df) <- c(ser_cName, date_cols, val_cName)
  row.names(out_df) <- NULL
  out_df
}
