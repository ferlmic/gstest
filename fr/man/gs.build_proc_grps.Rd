% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils-common.R
\name{gs.build_proc_grps}
\alias{gs.build_proc_grps}
\title{Construire des groupes de traitement de réconciliation}
\usage{
gs.build_proc_grps(
  ts_yr_vec,
  ts_per_vec,
  n_per,
  ts_freq,
  temporal_grp_periodicity,
  temporal_grp_start
)
}
\arguments{
\item{ts_yr_vec}{(obligatoire) Vecteur des valeurs d'année (unité de temps; voir \code{\link[=gs.time2year]{gs.time2year()}}).}

\item{ts_per_vec}{(obligatoire) Vecteur des valeurs de période (cycle; voir \code{\link[=gs.time2per]{gs.time2per()}}).}

\item{n_per}{(obligatoire) Longueur (nombre de périodes) de la série chronologique.}

\item{ts_freq}{(obligatoire) Fréquence de la srie chronologique (voir \code{\link[stats:time]{stats::frequency()}}).}

\item{temporal_grp_periodicity}{(obligatoire) Nombre de périodes dans les groupes temporels.}

\item{temporal_grp_start}{(obligatoire) Première période des groupes temporels.}
}
\value{
Un \emph{data frame} avec les variables (colonnes) suivantes :
\itemize{
\item \code{grp}         : vecteur de nombres entiers identifiant le groupe de traitement (1 .. < nombre de groupes >)
\item \code{beg_per}     : vecteur de nombres entiers identifiant la première période du groupe de traitement (1 .. \code{n_per})
\item \code{end_per}     : vecteur de nombres entiers identifiant la dernière période du groupe de traitement (1 .. \code{n_per})
\item \code{complete_grp}: Vecteur logique indiquant si le groupe de traitement correspond à un groupe temporel complet
}
}
\description{
Cette fonction construit le \emph{data frame} des groupes de traitement pour les problèmes de réconciliation.
Elle est utilisée à interne par \code{\link[=tsraking_driver]{tsraking_driver()}} et \code{\link[=tsbalancing]{tsbalancing()}}.
}
\section{Groupes de traitement}{
L'ensemble des périodes d'un problème de réconciliation (ratissage ou équilibrage) donné est appelé \emph{groupe de
traitement} et correspond soit :
\itemize{
\item à une \strong{période unique} lors d'un traitement période par période ou, lorsque les totaux temporels sont préservés,
pour les périodes individuelles d'un groupe temporel incomplet (ex., une année incomplète)
\item ou à l'\strong{ensemble des périodes d'un groupe temporel complet} (ex., une année complète) lorsque les totaux temporels
sont préservés.
}

Le nombre total de groupes de traitement (nombre total de problèmes de réconciliation) dépend de l'ensemble de périodes
des séries chronologiques d'entrée (objet de type série chronologique spécifié avec l'argument \code{in_ts}) et de la valeur
des arguments \code{temporal_grp_periodicity} et \code{temporal_grp_start}.

Les scénarios courants incluent \code{temporal_grp_periodicity = 1} (par défaut) pour un traitement période par période sans
préservation des totaux temporels et \ifelse{latex}{\code{temporal_grp_periodicity = freq uency(in_ts)}}{
\code{temporal_grp_periodicity = frequency(in_ts)}} pour la préservation des totaux annuels (années civiles par défaut).
L'argument \code{temporal_grp_start} permet de spécifier d'autres types d'années (\emph{non civile}). Par exemple, des années
financières commençant en avril correspondent à \code{temporal_grp_start = 4} avec des données mensuelles et à
\code{temporal_grp_start = 2} avec des données trimestrielles. La préservation des totaux trimestriels avec des données
mensuelles correspondrait à \code{temporal_grp_periodicity = 3}.

Par défaut, les groupes temporels convrant plus d'une année (c.-à-d., correspondant à \ifelse{latex}{\code{
temporal_grp _periodicity > frequency(in_ts)}}{\code{temporal_grp_periodicity > frequency(in_ts)}}) débutent avec une année
qui est un multiple de \ifelse{latex}{\code{ceiling( temporal_grp_periodicity / frequency(in_ts))}}{\code{
ceiling(temporal_grp_periodicity / frequency(in_ts))}}. Par exemple, les groupes bisannuels correspondant à
\code{temporal_grp_periodicity = 2 * frequency(in_ts)} débutent avec une \emph{année paire} par défaut. Ce comportement peut être
modifié avec l'argument \code{temporal_grp_start}. Par exemple, la préservation des totaux bisannuels débutant avec une \emph{année
impaire} au lieu d'une \emph{année paire} (par défaut) correspond à \code{temporal_grp_start = frequency(in_ts) + 1} (avec
\ifelse{latex}{\code{temporal_grp _periodicity = 2 * frequency(in_ts)}}{\code{temporal_grp_periodicity = 2 * frequency(in_ts)}}).

Voir les \strong{Exemples} de \code{\link[=gs.build_proc_grps]{gs.build_proc_grps()}} pour des scénarios courants de groupes de traitements.
}

\examples{
#######
# Configuration préalable

# Série chronologique mensuelle et trimestrielle « bidon » (2.5 années de longueur)
sc_men <- ts(rep(NA, 30), start = c(2019, 1), frequency = 12)
sc_men
sc_tri <- ts(rep(NA, 10), start = c(2019, 1), frequency = 4)
sc_tri

# Information résumée de la série chronologique
ts_info <- function(sc, sep = "-") {
  list(a = gs.time2year(sc),      # années
       p = gs.time2per(sc),       # périodes
       n = length(sc),            # longueur
       f = frequency(sc),         # fréquence
       e = gs.time2str(sc, sep))  # étiquettes
}
info_men <- ts_info(sc_men)
info_tri <- ts_info(sc_tri, sep = "t")

# Fonction qui ajoute une étiquette décrivant le groupe de traitement
ajouter_desc <- function(df_gr, vec_eti, mot, suf = "s") {
  df_gr$description <- ifelse(df_gr$complete_grp,
                              paste0("--- ", df_gr$end_per - df_gr$beg_per + 1, " ", mot, suf, " : ",
                                     vec_eti[df_gr$beg_per], " à ",
                                     vec_eti[df_gr$end_per], " ---"),
                              paste0("--- 1 ", mot, " : ", vec_eti[df_gr$beg_per], " ---"))
  df_gr
}




#######
# Scénarios courants de groupes de traitement pour des données mensuelles


# 0- Traitement mois par mois (chaque mois est un groupe de traitement)
gr_men0 <- gs.build_proc_grps(info_men$a, info_men$p, info_men$n, info_men$f,
                              temporal_grp_periodicity = 1,
                              temporal_grp_start = 1)
tmp <- ajouter_desc(gr_men0, info_men$e, "mois", "")
head(tmp)
tail(tmp)


# Groupes temporels correspondant à ...

# 1- des années civiles
gr_men1 <- gs.build_proc_grps(info_men$a, info_men$p, info_men$n, info_men$f,
                              temporal_grp_periodicity = 12,
                              temporal_grp_start = 1)
ajouter_desc(gr_men1, info_men$e, "mois", "")

# 2- des années financières commençant en avril
gr_men2 <- gs.build_proc_grps(info_men$a, info_men$p, info_men$n, info_men$f,
                              temporal_grp_periodicity = 12,
                              temporal_grp_start = 4)
ajouter_desc(gr_men2, info_men$e, "mois", "")

# 3- des trimestres réguliers (commençant en janvier, avril, juillet et octobre)
gr_men3 <- gs.build_proc_grps(info_men$a, info_men$p, info_men$n, info_men$f,
                              temporal_grp_periodicity = 3,
                              temporal_grp_start = 1)
ajouter_desc(gr_men3, info_men$e, "mois", "")

# 4- des trimestres décalés d'un mois (commençant en février, mai, août et novembre)
gr_men4 <- gs.build_proc_grps(info_men$a, info_men$p, info_men$n, info_men$f,
                              temporal_grp_periodicity = 3,
                              temporal_grp_start = 2)
ajouter_desc(gr_men4, info_men$e, "mois", "")




#######
# Scénarios courants de groupes de traitement pour des données trimestrielles


# 0- Traitement trimestre par trimestre (chaque trimestre est un groupe de traitement)
gr_tri0 <- gs.build_proc_grps(info_tri$a, info_tri$p, info_tri$n, info_tri$f,
                              temporal_grp_periodicity = 1,
                              temporal_grp_start = 1)
ajouter_desc(gr_tri0, info_tri$e, "trimestre")


# Groupes temporels correspondant à ...

# 1- des années civiles
gr_tri1 <- gs.build_proc_grps(info_tri$a, info_tri$p, info_tri$n, info_tri$f,
                              temporal_grp_periodicity = 4,
                              temporal_grp_start = 1)
ajouter_desc(gr_tri1, info_tri$e, "trimestre")

# 2- des années financières commençant en avril (2ième trimestre)
gr_tri2 <- gs.build_proc_grps(info_tri$a, info_tri$p, info_tri$n, info_tri$f,
                              temporal_grp_periodicity = 4,
                              temporal_grp_start = 2)
ajouter_desc(gr_tri2, info_tri$e, "trimestre")
}
\seealso{
\code{\link[=tsraking_driver]{tsraking_driver()}} \code{\link[=tsbalancing]{tsbalancing()}} \link{time_values_conv}
}
